
sourcing "nvim_exec2()"
line 1:     amenu     PopUp.Open\ in\ web\ browser  gx
line 2:     anoremenu PopUp.Inspect                 <Cmd>Inspect<CR>
line 3:     anoremenu PopUp.Go\ to\ definition      <Cmd>lua vim.lsp.buf.definition()<CR>
line 4:     anoremenu PopUp.Show\ Diagnostics       <Cmd>lua vim.diagnostic.open_float()<CR>
line 5:     anoremenu PopUp.Show\ All\ Diagnostics  <Cmd>lua vim.diagnostic.setqflist()<CR>
line 6:     anoremenu PopUp.Configure\ Diagnostics  <Cmd>help vim.diagnostic.config()<CR>
line 7:     anoremenu PopUp.-1-                     <Nop>
line 8:     vnoremenu PopUp.Cut                     "+x
line 9:     vnoremenu PopUp.Copy                    "+y
line 10:     anoremenu PopUp.Paste                   "+gP
line 11:     vnoremenu PopUp.Paste                   "+P
line 12:     vnoremenu PopUp.Delete                  "_x
line 13:     nnoremenu PopUp.Select\ All             ggVG
line 14:     vnoremenu PopUp.Select\ All             gg0oG$
line 15:     inoremenu PopUp.Select\ All             <C-Home><C-O>VG
line 16:     anoremenu PopUp.-2-                     <Nop>
line 17:     anoremenu PopUp.How-to\ disable\ mouse  <Cmd>help disable-mouse<CR>
line 18:   
finished sourcing nvim_exec2()
Searching for "ftplugin.vim" in runtime path
Searching for "/Users/josh/.config/nvim/ftplugin.vim"
Searching for "/Users/josh/.local/share/nvim/site/ftplugin.vim"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/ftplugin.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_load_ftplugin")
line 8:   finish
line 9: endif
line 10: let did_load_ftplugin = 1
line 11: 
line 12: augroup filetypeplugin
line 13:   au FileType * call s:LoadFTPlugin()
line 14: 
line 15:   func! s:LoadFTPlugin()
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/ftplugin.vim"
Searching for "/Users/josh/.config/nvim/after/ftplugin.vim"
Searching for "indent.vim" in runtime path
Searching for "/Users/josh/.config/nvim/indent.vim"
Searching for "/Users/josh/.local/share/nvim/site/indent.vim"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/indent.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   finish
line 9: endif
line 10: let did_indent_on = 1
line 11: 
line 12: augroup filetypeindent
line 13:   au FileType * call s:LoadIndent()
line 14:   func! s:LoadIndent()
line 33: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/indent.vim"
Searching for "/Users/josh/.config/nvim/after/indent.vim"
could not source "/opt/homebrew/etc/xdg/nvim/sysinit.vim"
could not source "/etc/xdg/nvim/sysinit.vim"
could not source "$VIM/sysinit.vim"
sourcing "/Users/josh/.config/nvim/init.vim"
line 1: set runtimepath^=~/.vim runtimepath+=~/.vim/after
line 2: let &packpath = &runtimepath
line 3: source ~/.vimrc
line 3: sourcing "/Users/josh/.vimrc"
line 1: " remap leader
line 2: let mapleader = "\<Space>"
line 3: 
line 4: " remember my buffers
line 5: exec 'set viminfo=%,' . &viminfo
line 5: set viminfo=%,!,'100,<50,s10,h
line 6: 
line 7: " syntax highlighting for things that might have large data
line 8: set maxmempattern=1048576
line 9: 
line 10: " properly handle colors in tmux
line 11: set t_Co=256
line 12: set t_ut=
line 13: 
line 14: " persistent undo
line 15: if has('persistent_undo')
line 16:     set undodir=$HOME/.vim/undo
line 17:     set undolevels=10000
line 18:     set undofile
line 19: endif
line 20: 
line 21: " system clipboard
line 22: set clipboard=unnamed
line 23: if system('uname -s') == 'Linux'
Executing command: "'/bin/zsh' '-c' 'uname -s'"


line 24:     set clipboard=unnamedplus
line 25: endif
line 26: 
line 27: " speed things up
line 28: set lazyredraw
line 29: set ttyfast
line 30: 
line 31: " syntax highlighting
line 32: " syntax on
line 33: " filetype off
line 34: filetype plugin indent off
Searching for "ftplugof.vim" in runtime path
Searching for "/Users/josh/.vim/ftplugof.vim"
Searching for "/Users/josh/.config/nvim/ftplugof.vim"
Searching for "/Users/josh/.local/share/nvim/site/ftplugof.vim"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/ftplugof.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugof.vim"
line 34: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugof.vim"
line 1: " Vim support file to switch off loading plugins for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_load_ftplugin")
line 8:   unlet did_load_ftplugin
line 9: endif
line 10: 
line 11: " Remove all autocommands in the filetypeplugin group, if any exist.
line 12: if exists("#filetypeplugin")
line 13:   silent! au! filetypeplugin *
line 14: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugof.vim
continuing in /Users/josh/.vimrc
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/ftplugof.vim"
Searching for "/Users/josh/.config/nvim/after/ftplugof.vim"
Searching for "indoff.vim" in runtime path
Searching for "/Users/josh/.vim/indoff.vim"
Searching for "/Users/josh/.config/nvim/indoff.vim"
Searching for "/Users/josh/.local/share/nvim/site/indoff.vim"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/indoff.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indoff.vim"
line 34: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indoff.vim"
line 1: " Vim support file to switch off loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   unlet did_indent_on
line 9: endif
line 10: 
line 11: " Remove all autocommands in the filetypeindent group
line 12: silent! au! filetypeindent *
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indoff.vim
continuing in /Users/josh/.vimrc
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/indoff.vim"
Searching for "/Users/josh/.config/nvim/after/indoff.vim"
line 35: 
line 36: " nvim terminal
line 37: tnoremap <Esc> <C-\><C-n>
line 38: 
line 39: call plug#begin('~/.vim/plugged')
Searching for "autoload/plug.vim" in runtime path
Searching for "/Users/josh/.vim/autoload/plug.vim"
Searching for "/Users/josh/.config/nvim/autoload/plug.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/plug.vim"
line 39: sourcing "/Users/josh/.local/share/nvim/site/autoload/plug.vim"
line 1: " vim-plug: Vim plugin manager
line 2: " ============================
line 3: "
line 4: " 1. Download plug.vim and put it in 'autoload' directory
line 5: "
line 6: "   # Vim
line 7: "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
line 8: "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
line 9: "
line 10: "   # Neovim
line 11: "   sh -c 'curl -fLo "${XDG_DATA_HOME:-$HOME/.local/share}"/nvim/site/autoload/plug.vim --create-dirs \
line 12: "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
line 13: "
line 14: " 2. Add a vim-plug section to your ~/.vimrc (or ~/.config/nvim/init.vim for Neovim)
line 15: "
line 16: "   call plug#begin()
line 17: "
line 18: "   " List your plugins here
line 19: "   Plug 'tpope/vim-sensible'
line 20: "
line 21: "   call plug#end()
line 22: "
line 23: " 3. Reload the file or restart Vim, then you can,
line 24: "
line 25: "     :PlugInstall to install plugins
line 26: "     :PlugUpdate  to update plugins
line 27: "     :PlugDiff    to review the changes from the last update
line 28: "     :PlugClean   to remove plugins no longer in the list
line 29: "
line 30: " For more information, see https://github.com/junegunn/vim-plug
line 31: "
line 32: "
line 33: " Copyright (c) 2024 Junegunn Choi
line 34: "
line 35: " MIT License
line 36: "
line 37: " Permission is hereby granted, free of charge, to any person obtaining
line 38: " a copy of this software and associated documentation files (the
line 39: " "Software"), to deal in the Software without restriction, including
line 40: " without limitation the rights to use, copy, modify, merge, publish,
line 41: " distribute, sublicense, and/or sell copies of the Software, and to
line 42: " permit persons to whom the Software is furnished to do so, subject to
line 43: " the following conditions:
line 44: "
line 45: " The above copyright notice and this permission notice shall be
line 46: " included in all copies or substantial portions of the Software.
line 47: "
line 48: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 49: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 50: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 51: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 52: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 53: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 54: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 55: 
line 56: if exists('g:loaded_plug')
line 57:   finish
line 58: endif
line 59: let g:loaded_plug = 1
line 60: 
line 61: let s:cpo_save = &cpo
line 62: set cpo&vim
line 63: 
line 64: let s:plug_src = 'https://github.com/junegunn/vim-plug.git'
line 65: let s:plug_tab = get(s:, 'plug_tab', -1)
line 66: let s:plug_buf = get(s:, 'plug_buf', -1)
line 67: let s:mac_gui = has('gui_macvim') && has('gui_running')
line 68: let s:is_win = has('win32')
line 69: let s:nvim = has('nvim-0.2') || (has('nvim') && exists('*jobwait') && !s:is_win)
line 70: let s:vim8 = has('patch-8.0.0039') && exists('*job_start')
line 71: if s:is_win && &shellslash
line 72:   set noshellslash
line 73:   let s:me = resolve(expand('<sfile>:p'))
line 74:   set shellslash
line 75: else
line 76:   let s:me = resolve(expand('<sfile>:p'))
line 77: endif
line 78: let s:base_spec = { 'branch': '', 'frozen': 0 }
line 79: let s:TYPE = {   'string':  type(''),   'list':    type([]),   'dict':    type({}),   'funcref': type(function('call')) }
line 85: let s:loaded = get(s:, 'loaded', {})
line 86: let s:triggers = get(s:, 'triggers', {})
line 87: 
line 88: function! s:is_powershell(shell)
line 91: 
line 92: function! s:isabsolute(dir) abort
line 95: 
line 96: function! s:git_dir(dir) abort
line 110: 
line 111: function! s:git_origin_url(dir) abort
line 119: 
line 120: function! s:git_revision(dir) abort
line 147: 
line 148: function! s:git_local_branch(dir) abort
line 157: 
line 158: function! s:git_origin_branch(spec)
line 175: 
line 176: if s:is_win
line 177:   function! s:plug_call(fn, ...)
line 186: else
line 187:   function! s:plug_call(fn, ...)
line 190: endif
line 191: 
line 192: function! s:plug_getcwd()
line 195: 
line 196: function! s:plug_fnamemodify(fname, mods)
line 199: 
line 200: function! s:plug_expand(fmt)
line 203: 
line 204: function! s:plug_tempname()
line 207: 
line 208: function! plug#begin(...)
line 232: 
line 233: function! s:define_commands()
line 256: 
line 257: function! s:to_a(v)
line 260: 
line 261: function! s:to_s(v)
line 264: 
line 265: function! s:glob(from, pattern)
line 268: 
line 269: function! s:source(from, ...)
line 279: 
line 280: function! s:assoc(dict, key, val)
line 283: 
line 284: function! s:ask(message, ...)
line 293: 
line 294: function! s:ask_no_interrupt(...)
line 301: 
line 302: function! s:lazy(plug, opt)
line 309: 
line 310: function! plug#end()
line 405: 
line 406: function! s:loaded_names()
line 409: 
line 410: function! s:load_plugin(spec)
line 416: 
line 417: function! s:reload_plugins()
line 422: 
line 423: function! s:trim(str)
line 426: 
line 427: function! s:version_requirement(val, min)
line 436: 
line 437: function! s:git_version_requirement(...)
line 443: 
line 444: function! s:progress_opt(base)
line 448: 
line 449: function! s:rtp(spec)
line 452: 
line 453: if s:is_win
line 454:   function! s:path(path)
line 457: 
line 458:   function! s:dirpath(path)
line 461: 
line 462:   function! s:is_local_plug(repo)
line 465: 
line 466:   " Copied from fzf
line 467:   function! s:wrap_cmds(cmds)
line 481: 
line 482:   function! s:batchfile(cmd)
line 491: else
line 492:   function! s:path(path)
line 495: 
line 496:   function! s:dirpath(path)
line 499: 
line 500:   function! s:is_local_plug(repo)
line 503: endif
line 504: 
line 505: function! s:err(msg)
line 510: 
line 511: function! s:warn(cmd, msg)
line 516: 
line 517: function! s:esc(path)
line 520: 
line 521: function! s:escrtp(path)
line 524: 
line 525: function! s:remove_rtp()
line 535: 
line 536: function! s:reorg_rtp()
line 562: 
line 563: function! s:doautocmd(...)
line 568: 
line 569: function! s:dobufread(names)
line 582: 
line 583: function! plug#load(...)
line 606: 
line 607: function! s:remove_triggers(name)
line 620: 
line 621: function! s:lod(names, types, ...)
line 645: 
line 646: function! s:lod_ft(pat, names)
line 653: 
line 654: function! s:lod_cmd(cmd, bang, l1, l2, args, names)
line 659: 
line 660: function! s:lod_map(map, names, with_prefix, prefix)
line 685: 
line 686: function! plug#(repo, ...)
line 705: 
line 706: function! s:parse_options(arg)
line 743: 
line 744: function! s:infer_properties(name, repo)
line 761: 
line 762: function! s:install(force, names)
line 765: 
line 766: function! s:update(force, names)
line 769: 
line 770: function! plug#helptags()
line 782: 
line 783: function! s:syntax()
line 837: 
line 838: function! s:lpad(str, len)
line 841: 
line 842: function! s:lines(msg)
line 845: 
line 846: function! s:lastline(msg)
line 849: 
line 850: function! s:new_window()
line 853: 
line 854: function! s:plug_window_exists()
line 858: 
line 859: function! s:switch_in()
line 877: 
line 878: function! s:switch_out(...)
line 891: 
line 892: function! s:finish_bindings()
line 901: 
line 902: function! s:prepare(...)
line 944: 
line 945: function! s:close_pane()
line 955: 
line 956: function! s:assign_name()
line 967: 
line 968: function! s:chsh(swap)
line 982: 
line 983: function! s:bang(cmd, ...)
line 1004: 
line 1005: function! s:regress_bar()
line 1009: 
line 1010: function! s:is_updated(dir)
line 1013: 
line 1014: function! s:do(pull, force, todo)
line 1073: 
line 1074: function! s:hash_match(a, b)
line 1077: 
line 1078: function! s:checkout(spec)
line 1090: 
line 1091: function! s:finish(pull)
line 1114: 
line 1115: function! s:retry()
line 1123: 
line 1124: function! s:is_managed(name)
line 1127: 
line 1128: function! s:names(...)
line 1131: 
line 1132: function! s:check_ruby()
line 1142: 
line 1143: function! s:update_impl(pull, force, args) abort
line 1266: 
line 1267: function! s:log4(name, msg)
line 1271: 
line 1272: function! s:update_finish()
line 1332: 
line 1333: function! s:mark_aborted(name, message)
line 1337: 
line 1338: function! s:job_abort(cancel)
line 1365: 
line 1366: function! s:last_non_empty_line(lines)
line 1376: 
line 1377: function! s:bullet_for(job, ...)
line 1386: 
line 1387: function! s:job_out_cb(self, data) abort
line 1401: 
line 1402: function! s:job_exit_cb(self, data) abort
line 1408: 
line 1409: function! s:job_cb(fn, job, ch, data)
line 1415: 
line 1416: function! s:nvim_cb(job_id, data, event) dict abort
line 1421: 
line 1422: function! s:spawn(name, spec, queue, opts)
line 1473: 
line 1474: function! s:reap(name)
line 1496: 
line 1497: function! s:bar()
line 1506: 
line 1507: function! s:logpos(name)
line 1521: 
line 1522: function! s:log(bullet, name, lines)
line 1539: 
line 1540: function! s:update_vim()
line 1546: 
line 1547: function! s:checkout_command(spec)
line 1551: 
line 1552: function! s:merge_command(spec)
line 1556: 
line 1557: function! s:tick()
line 1629: 
line 1630: function! s:update_python()
line 2018: 
line 2019: function! s:update_ruby()
line 2244: 
line 2245: function! s:shellesc_cmd(arg, script)
line 2249: 
line 2250: function! s:shellesc_ps1(arg)
line 2253: 
line 2254: function! s:shellesc_sh(arg)
line 2257: 
line 2258: " Escape the shell argument based on the shell.
line 2259: " Vim and Neovim's shellescape() are insufficient.
line 2260: " 1. shellslash determines whether to use single/double quotes.
line 2261: "    Double-quote escaping is fragile for cmd.exe.
line 2262: " 2. It does not work for powershell.
line 2263: " 3. It does not work for *sh shells if the command is executed
line 2264: "    via cmd.exe (ie. cmd.exe /c sh -c command command_args)
line 2265: " 4. It does not support batchfile syntax.
line 2266: "
line 2267: " Accepts an optional dictionary with the following keys:
line 2268: " - shell: same as Vim/Neovim 'shell' option.
line 2269: "          If unset, fallback to 'cmd.exe' on Windows or 'sh'.
line 2270: " - script: If truthy and shell is cmd.exe, escape for batchfile syntax.
line 2271: function! plug#shellescape(arg, ...)
line 2285: 
line 2286: function! s:glob_dir(path)
line 2289: 
line 2290: function! s:progress_bar(line, bar, total)
line 2293: 
line 2294: function! s:compare_git_uri(a, b)
line 2305: 
line 2306: function! s:format_message(bullet, name, message)
line 2314: 
line 2315: function! s:with_cd(cmd, dir, ...)
line 2322: 
line 2323: function! s:system(cmd, ...)
line 2355: 
line 2356: function! s:system_chomp(...)
line 2360: 
line 2361: function! s:git_validate(spec, check_branch)
line 2424: 
line 2425: function! s:rm_rf(dir)
line 2432: 
line 2433: function! s:clean(force)
line 2503: 
line 2504: function! s:delete_op(type, ...)
line 2507: 
line 2508: function! s:delete(range, force)
line 2542: 
line 2543: function! s:upgrade()
line 2569: 
line 2570: function! s:upgrade_specs()
line 2575: 
line 2576: function! s:status()
line 2621: 
line 2622: function! s:extract_name(str, prefix, suffix)
line 2625: 
line 2626: function! s:status_load(lnum)
line 2636: 
line 2637: function! s:status_update() range
line 2645: 
line 2646: function! s:is_preview_window_open()
line 2653: 
line 2654: function! s:find_name(lnum)
line 2667: 
line 2668: function! s:preview_commit()
line 2717: 
line 2718: function! s:section(flags)
line 2721: 
line 2722: function! s:format_git_log(line)
line 2733: 
line 2734: function! s:append_ul(lnum, text)
line 2737: 
line 2738: function! s:diff()
line 2798: 
line 2799: function! s:revert()
line 2816: 
line 2817: function! s:snapshot(force, ...) abort
line 2848: 
line 2849: function! s:split_rtp()
line 2852: 
line 2853: let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))
calling <SNR>8_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')
<SNR>8_split_rtp returning ['/Users/josh/.vim', '/Users/josh/.con.../nvim/after', '/Users/josh/.vim/after']

continuing in /Users/josh/.local/share/nvim/site/autoload/plug.vim

calling <SNR>8_escrtp('/Users/josh/.vim')

line 1:   return escape(a:path, ' ,')
<SNR>8_escrtp returning '/Users/josh/.vim'

continuing in /Users/josh/.local/share/nvim/site/autoload/plug.vim

line 2854: let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))
calling <SNR>8_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')
<SNR>8_split_rtp returning ['/Users/josh/.vim', '/Users/josh/.con.../nvim/after', '/Users/josh/.vim/after']

continuing in /Users/josh/.local/share/nvim/site/autoload/plug.vim

calling <SNR>8_escrtp('/Users/josh/.vim/after')

line 1:   return escape(a:path, ' ,')
<SNR>8_escrtp returning '/Users/josh/.vim/after'

continuing in /Users/josh/.local/share/nvim/site/autoload/plug.vim

line 2855: 
line 2856: if exists('g:plugs')
line 2857:   let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))
line 2858:   call s:upgrade_specs()
line 2859:   call s:define_commands()
line 2860: endif
line 2861: 
line 2862: let &cpo = s:cpo_save
line 2863: unlet s:cpo_save
finished sourcing /Users/josh/.local/share/nvim/site/autoload/plug.vim
continuing in /Users/josh/.vimrc
calling plug#begin('~/.vim/plugged')

line 1:   if a:0 > 0
line 2:     let home = s:path(s:plug_fnamemodify(s:plug_expand(a:1), ':p'))
calling <SNR>8_plug_expand('~/.vim/plugged')

line 1:   return s:plug_call('expand', a:fmt, 1)
calling <SNR>8_plug_call('expand', '~/.vim/plugged', 1)

line 1:     return call(a:fn, a:000)
<SNR>8_plug_call returning '/Users/josh/.vim/plugged'

continuing in <SNR>8_plug_expand

<SNR>8_plug_expand returning '/Users/josh/.vim/plugged'

continuing in plug#begin

calling <SNR>8_plug_fnamemodify('/Users/josh/.vim/plugged', ':p')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>8_plug_call('fnamemodify', '/Users/josh/.vim/plugged', ':p')

line 1:     return call(a:fn, a:000)
<SNR>8_plug_call returning '/Users/josh/.vim/plugged/'

continuing in <SNR>8_plug_fnamemodify

<SNR>8_plug_fnamemodify returning '/Users/josh/.vim/plugged/'

continuing in plug#begin

calling <SNR>8_path('/Users/josh/.vim/plugged/')

line 1:     return s:trim(a:path)
calling <SNR>8_trim('/Users/josh/.vim/plugged/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
<SNR>8_trim returning '/Users/josh/.vim/plugged'

continuing in <SNR>8_path

<SNR>8_path returning '/Users/josh/.vim/plugged'

continuing in plug#begin

line 3:   elseif exists('g:plug_home')
line 4:     let home = s:path(g:plug_home)
line 5:   elseif has('nvim')
line 6:     let home = stdpath('data') . '/plugged'
line 7:   elseif !empty(&rtp)
line 8:     let home = s:path(split(&rtp, ',')[0]) . '/plugged'
line 9:   else
line 10:     return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
line 11:   endif
line 12:   if s:plug_fnamemodify(home, ':t') ==# 'plugin' && s:plug_fnamemodify(home, ':h') ==# s:first_rtp
calling <SNR>8_plug_fnamemodify('/Users/josh/.vim/plugged', ':t')

line 1:   return s:plug_call('fnamemodify', a:fname, a:mods)
calling <SNR>8_plug_call('fnamemodify', '/Users/josh/.vim/plugged', ':t')

line 1:     return call(a:fn, a:000)
<SNR>8_plug_call returning 'plugged'

continuing in <SNR>8_plug_fnamemodify

<SNR>8_plug_fnamemodify returning 'plugged'

continuing in plug#begin

line 13:     return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
line 14:   endif
line 15: 
line 16:   let g:plug_home = home
line 17:   let g:plugs = {}
line 18:   let g:plugs_order = []
line 19:   let s:triggers = {}
line 20: 
line 21:   call s:define_commands()
calling <SNR>8_define_commands()

line 1:   command! -nargs=+ -bar Plug call plug#(<args>)
line 2:   if !executable('git')
line 3:     return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
line 4:   endif
line 5:   if has('win32') && &shellslash && (&shell =~# 'cmd\(\.exe\)\?$' || s:is_powershell(&shell))
line 8:     return s:err('vim-plug does not support shell, ' . &shell . ', when shellslash is set.')
line 9:   endif
line 10:   if !has('nvim') && (has('win32') || has('win32unix')) && !has('multi_byte')
line 13:     return s:err('Vim needs +multi_byte feature on Windows to run shell commands. Enable +iconv for best results.')
line 14:   endif
line 15:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
line 16:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
line 17:   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
line 18:   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
line 19:   command! -nargs=0 -bar PlugStatus  call s:status()
line 20:   command! -nargs=0 -bar PlugDiff    call s:diff()
line 21:   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)
<SNR>8_define_commands returning #0

continuing in plug#begin

line 22:   return 1
plug#begin returning #1

continuing in /Users/josh/.vimrc

line 40: 
line 41: " Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
line 42: " Plug 'junegunn/fzf.vim'
line 43: let g:fzf_buffers_jump = 1
line 44: let $FZF_DEFAULT_OPTS = '--bind ctrl-a:select-all'
line 45: function! s:build_quickfix_list(lines)
line 50: let g:fzf_action = { 'ctrl-q': function('s:build_quickfix_list'), 'ctrl-t': 'tab split', 'ctrl-x': 'split', 'ctrl-v': 'vsplit' }
line 55: 
line 56: " Plug 'tpope/vim-commentary'
line 57: nnoremap <Leader>/ :Commentary<CR><Esc>
line 58: vnoremap <Leader>/ :Commentary<CR><Esc>
line 59: 
line 60: " Plug 'SirVer/ultisnips'
line 61: let g:UltiSnipsExpandTrigger="<tab>"
line 62: let g:UltiSnipsJumpForwardTrigger='<c-j>'
line 63: let g:UltiSnipsJumpBackwardTrigger='<c-k>'
line 64: let g:UltiSnipsEditSplit='horizontal'
line 65: " Plug 'quangnguyen30192/cmp-nvim-ultisnips'
line 66: 
line 67: " Plug 'jeetsukumaran/vim-buffergator'
line 68: let g:buffergator_suppress_keymaps = 1
line 69: let g:buffergator_sort_regime = "mru"
line 70: let g:buffergator_show_full_directory_path = 0
line 71: let g:buffergator_vsplit_size = 60
line 72: let g:buffergator_viewport_split_policy = "L"
line 73: 
line 74: " Plug 'skywind3000/vim-terminal-help'
line 75: let g:terminal_key = "<c-h>"
line 76: let g:terminal_height = 25
line 77: let g:terminal_pos = "topleft"
line 78: let g:terminal_close = 1
line 79: let g:terminal_cwd = 0
line 80: let g:terminal_list = 0 " hide terminal in buffers list
line 81: 
line 82: call plug#end()
calling plug#end()

line 1:   if !exists('g:plugs')
line 2:     return s:err('plug#end() called without calling plug#begin() first')
line 3:   endif
line 4: 
line 5:   if exists('#PlugLOD')
line 6:     augroup PlugLOD
line 7:       autocmd!
line 8:     augroup END
line 9:     augroup! PlugLOD
line 10:   endif
line 11:   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
line 12: 
line 13:   if get(g:, 'did_load_filetypes', 0)
line 14:     filetype off
line 15:   endif
line 16:   for name in g:plugs_order
line 17:     if !has_key(g:plugs, name)
line 18:       continue
line 19:     endif
line 20:     let plug = g:plugs[name]
line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
line 22:       let s:loaded[name] = 1
line 23:       continue
line 24:     endif
line 25: 
line 26:     if has_key(plug, 'on')
line 27:       let s:triggers[name] = { 'map': [], 'cmd': [] }
line 28:       for cmd in s:to_a(plug.on)
line 29:         if cmd =~? '^<Plug>.\+'
line 30:           if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
line 31:             call s:assoc(lod.map, cmd, name)
line 32:           endif
line 33:           call add(s:triggers[name].map, cmd)
line 34:         elseif cmd =~# '^[A-Z]'
line 35:           let cmd = substitute(cmd, '!*$', '', '')
line 36:           if exists(':'.cmd) != 2
line 37:             call s:assoc(lod.cmd, cmd, name)
line 38:           endif
line 39:           call add(s:triggers[name].cmd, cmd)
line 40:         else
line 41:           call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')
line 43:         endif
line 44:       endfor
line 45:     endif
line 46: 
line 47:     if has_key(plug, 'for')
line 48:       let types = s:to_a(plug.for)
line 49:       if !empty(types)
line 50:         augroup filetypedetect
line 51:         call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
line 52:         if has('nvim-0.5.0')
line 53:           call s:source(s:rtp(plug), 'ftdetect/**/*.lua', 'after/ftdetect/**/*.lua')
line 54:         endif
line 55:         augroup END
line 56:       endif
line 57:       for type in types
line 58:         call s:assoc(lod.ft, type, name)
line 59:       endfor
line 60:     endif
line 61:   endfor
line 62: 
line 63:   for [cmd, names] in items(lod.cmd)
line 64:     execute printf( 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))
line 67:   endfor
line 68: 
line 69:   for [map, names] in items(lod.map)
line 70:     for [mode, map_prefix, key_prefix] in [['i', '<C-\><C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
line 72:       execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
line 75:     endfor
line 76:   endfor
line 77: 
line 78:   for [ft, names] in items(lod.ft)
line 79:     augroup PlugLOD
line 80:       execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))
line 82:     augroup END
line 83:   endfor
line 84: 
line 85:   call s:reorg_rtp()
calling <SNR>8_reorg_rtp()

line 1:   if !empty(s:first_rtp)
line 2:     execute 'set rtp-='.s:first_rtp
line 2: set rtp-=/Users/josh/.vim
line 3:     execute 'set rtp-='.s:last_rtp
line 3: set rtp-=/Users/josh/.vim/after
line 4:   endif
line 5: 
line 6:   " &rtp is modified from outside
line 7:   if exists('s:prtp') && s:prtp !=# &rtp
line 8:     call s:remove_rtp()
line 9:     unlet! s:middle
line 10:   endif
line 11: 
line 12:   let s:middle = get(s:, 'middle', &rtp)
line 13:   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
calling <SNR>8_loaded_names()

line 1:   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')
<SNR>8_loaded_names returning []

continuing in <SNR>8_reorg_rtp

line 14:   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
line 15:   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
line 18:   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
line 19:   let s:prtp   = &rtp
line 20: 
line 21:   if !empty(s:first_rtp)
line 22:     execute 'set rtp^='.s:first_rtp
line 22: set rtp^=/Users/josh/.vim
line 23:     execute 'set rtp+='.s:last_rtp
line 23: set rtp+=/Users/josh/.vim/after
line 24:   endif
<SNR>8_reorg_rtp returning #0

continuing in plug#end

line 86:   filetype plugin indent on
Searching for "filetype.lua filetype.vim" in runtime path
Searching for "/Users/josh/.vim/filetype.lua"
Searching for "/Users/josh/.vim/filetype.vim"
Searching for "/Users/josh/.config/nvim/filetype.lua"
Searching for "/Users/josh/.config/nvim/filetype.vim"
Searching for "/Users/josh/.local/share/nvim/site/filetype.lua"
Searching for "/Users/josh/.local/share/nvim/site/filetype.vim"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/filetype.lua"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua"
line 86: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua"
line 0: sourcing "nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua:0"
line 1:   augroup filetypedetect
line 2:   runtime! ftdetect/*.{vim,lua}
Searching for "ftdetect/*.{vim,lua}" in runtime path
Searching for "/Users/josh/.vim/ftdetect/*.{vim,lua}"
Searching for "/Users/josh/.config/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/josh/.local/share/nvim/site/ftdetect/*.{vim,lua}"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/ftdetect/*.{vim,lua}"
line 2: sourcing "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/ftdetect/ghostty.vim"
line 1: " Vim filetype detect file
line 2: " Language: Ghostty config file
line 3: " Maintainer: Ghostty <https://github.com/ghostty-org/ghostty>
line 4: "
line 5: " THIS FILE IS AUTO-GENERATED
line 6: 
line 7: au BufRead,BufNewFile */ghostty/config,*/ghostty/themes/* set ft=ghostty
finished sourcing /Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/ftdetect/ghostty.vim
continuing in nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua:0
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/josh/.config/nvim/after/ftdetect/*.{vim,lua}"
line 3:   augroup END
finished sourcing nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua:0
continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua
continuing in plug#end
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/filetype.vim"
Searching for "/Users/josh/.config/nvim/after/filetype.lua"
Searching for "/Users/josh/.config/nvim/after/filetype.vim"
Searching for "ftplugin.vim" in runtime path
Searching for "/Users/josh/.vim/ftplugin.vim"
Searching for "/Users/josh/.config/nvim/ftplugin.vim"
Searching for "/Users/josh/.local/share/nvim/site/ftplugin.vim"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/ftplugin.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim"
line 86: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_load_ftplugin")
line 8:   finish
line 9: endif
line 10: let did_load_ftplugin = 1
line 11: 
line 12: augroup filetypeplugin
line 13:   au FileType * call s:LoadFTPlugin()
line 14: 
line 15:   func! s:LoadFTPlugin()
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim
continuing in plug#end
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/ftplugin.vim"
Searching for "/Users/josh/.config/nvim/after/ftplugin.vim"
Searching for "indent.vim" in runtime path
Searching for "/Users/josh/.vim/indent.vim"
Searching for "/Users/josh/.config/nvim/indent.vim"
Searching for "/Users/josh/.local/share/nvim/site/indent.vim"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/indent.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim"
line 86: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   finish
line 9: endif
line 10: let did_indent_on = 1
line 11: 
line 12: augroup filetypeindent
line 13:   au FileType * call s:LoadIndent()
line 14:   func! s:LoadIndent()
line 33: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim
continuing in plug#end
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/indent.vim"
Searching for "/Users/josh/.config/nvim/after/indent.vim"
line 87:   if has('vim_starting')
line 88:     if has('syntax') && !exists('g:syntax_on')
line 89:       syntax enable
line 89: so $VIMRUNTIME/syntax/syntax.vim
line 89: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in runtime path
Searching for "/Users/josh/.vim/syntax/synload.vim"
Searching for "/Users/josh/.config/nvim/syntax/synload.vim"
Searching for "/Users/josh/.local/share/nvim/site/syntax/synload.vim"
Searching for "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/syntax/synload.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/synload.vim"
line 20: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Line continuation is used here, remove 'C' from 'cpoptions'
line 19: let s:cpo_save = &cpo
line 20: set cpo&vim
line 21: 
line 22: " First remove all old syntax autocommands.
line 23: au! Syntax
line 24: 
line 25: au Syntax *^I^Icall s:SynSet()
line 26: 
line 27: fun! s:SynSet()
line 58: 
line 59: 
line 60: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 61: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 66: 
line 67: 
line 68: " Source the user-specified syntax highlighting file
line 69: if exists("mysyntaxfile")
line 70:   let s:fname = expand(mysyntaxfile)
line 71:   if filereadable(s:fname)
line 72:     execute "source " . fnameescape(s:fname)
line 73:   endif
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/synload.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected
line 32: " unless treesitter highlighting is enabled.
line 33: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 34: augroup syntaxset
line 35:   au! FileType *^Iif !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
line 36: augroup END
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
line 45: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/syntax.vim
continuing in plug#end
line 90:     end
line 91:   else
line 92:     call s:reload_plugins()
line 93:   endif
plug#end returning #0

continuing in /Users/josh/.vimrc

line 83: 
line 84: let $FZF_DEFAULT_OPTS="--preview-window 'right:57%' --preview 'bat --style=numbers --line-range :300 {}' --bind ctrl-y:preview-up,ctrl-e:preview-down"
line 86: 
line 87: " keymap | general
line 88: " make saving easier
line 89: nnoremap <Leader>w :w<CR>
line 90: " this piece of trash needs to die
line 91: map Q <Nop>
line 92: " don't yank when pasting
line 93: 
line 94: inoremap <C-@> <C-x><C-o>
line 95: "make Y copy to the end of the line
line 96: nnoremap Y y$
line 97: " searching should keep the cursor in the same place
line 98: "nnoremap n nzt
line 99: "nnoremap N Nzt
line 100: " undo break points..don't undo every damn thing from last insert
line 101: inoremap , ,<c-g>u
line 102: inoremap = =<c-g>u
line 103: inoremap , ,<c-g>u
line 104: inoremap . .<c-g>u
line 105: "duplicate (copy) blocks of text
line 106: nnoremap <Leader>cb Va}:t'><CR>
line 107: 
line 108: " yank current word and paste into Ag
line 109: nnoremap <Leader>fl :G log -p --follow -- %<CR>
line 110: nnoremap <Leader>fg :G<CR>
line 111: " folding
line 112: nnoremap <Leader>rf vi{zF
line 113: 
line 114: nnoremap <Leader>rs :wa<CR>:mksession!<CR>:qa
line 115: " execute the test I'm in then jump back
line 116: nnoremap <Leader>cf m':call search("^func", "b")<cr>Wyiw<C-o>
line 117: 
line 118: " keymap | navigation
line 119: nnoremap <Leader>gv :exe 'AsyncRun -mode=term cd '.expand('%:p:h').' && go vet ./... && echo checks out'<CR>
line 120: nmap <C-k> :cprev<CR>
line 121: nmap <C-j> :cnext<CR>
line 122: 
line 123: " see current file changes master
line 124: nnoremap <Leader>cm :Gdiffsplit origin/master<CR>
line 125: 
line 126: " keymap | search
line 127: " search selected text on / in visual mode
line 128: vnoremap / <Esc>/\%V
line 129: 
line 130: " highlight extra whitespace
line 131: " keep this at the bottom
line 132: hi ExtraWhitespace ctermbg=red guibg=red
line 133: match ExtraWhitespace /\s\+$/
line 134: 
line 135: " stop indention "help"
line 136: " filetype indent off
line 137: " set noautoindent
line 138: " set nocindent
line 139: " set nosmartindent
line 140: " set indentexpr=
line 141: 
line 142: " remember line position
line 143: autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
line 144: 
line 145: autocmd FileType go nnoremap <Leader>go :AsyncRun -mode=term go doc -all %:p:h<CR>
line 146: 
line 147: " navigate between functions
line 148: autocmd FileType go nnoremap ]] :call search("^func")<cr>zt
line 149: autocmd FileType go nnoremap [[ :call search("^func", "b")<cr>zt
line 150: 
line 151: " change cursorline on insert
line 152: set cursorline
line 153: autocmd InsertEnter * set nocursorline
line 154: autocmd InsertLeave * set cursorline
line 155: 
line 156: " better window naming
line 157: autocmd BufReadPost,FileReadPost,BufNewFile * call system("tmux rename-window " . expand("%"))
line 158: 
finished sourcing /Users/josh/.vimrc
continuing in /Users/josh/.config/nvim/init.vim
line 4: 
line 5: lua require('config.debug')
line 6: lua require('config.vim')
line 7: lua require('config.lazy')
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/gitsigns.nvim/plugin/gitsigns.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/plugin/gitsigns.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/gitsigns.nvim/plugin/gitsigns.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua"
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua:0"
line 1: source /Users/josh/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua"
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallSync lua require'nvim-treesitter.install'.commands.TSInstallSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#installed_parsers TSUninstall lua require'nvim-treesitter.install'.commands.TSUninstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallFromGrammar lua require'nvim-treesitter.install'.commands.TSInstallFromGrammar['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstall lua require'nvim-treesitter.install'.commands.TSInstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdateSync lua require'nvim-treesitter.install'.commands.TSUpdateSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdate lua require'nvim-treesitter.install'.commands.TSUpdate['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSInstallInfo lua require'nvim-treesitter.info'.commands.TSInstallInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=? -complete=custom,nvim_treesitter#available_modules TSModuleInfo lua require'nvim-treesitter.info'.commands.TSModuleInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSToggle lua require'nvim-treesitter.configs'.commands.TSToggle['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSDisable lua require'nvim-treesitter.configs'.commands.TSDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSEnable lua require'nvim-treesitter.configs'.commands.TSEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufToggle lua require'nvim-treesitter.configs'.commands.TSBufToggle['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufDisable lua require'nvim-treesitter.configs'.commands.TSBufDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufEnable lua require'nvim-treesitter.configs'.commands.TSBufEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQueryUserAfter lua require'nvim-treesitter.configs'.commands.TSEditQueryUserAfter['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQuery lua require'nvim-treesitter.configs'.commands.TSEditQuery['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSConfigInfo lua require'nvim-treesitter.configs'.commands.TSConfigInfo['run<bang>'](<f-args>)
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
continuing in nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua:0
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua:0"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua:0"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua
Searching for "parser/lua.so" in runtime path
Searching for "/Users/josh/.config/nvim/parser/lua.so"
Searching for "/Users/josh/.local/share/nvim/site/parser/lua.so"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/parser/lua.so"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/parser/lua.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/parser/lua.so"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/parser/lua.so"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/parser/lua.so"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/parser/lua.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/after/parser/lua.so"
Searching for "/Users/josh/.config/nvim/after/parser/lua.so"
Searching for "/Users/josh/.local/state/nvim/lazy/readme/parser/lua.so"
Searching for "parser/vim.so" in runtime path
Searching for "/Users/josh/.config/nvim/parser/vim.so"
Searching for "/Users/josh/.local/share/nvim/site/parser/vim.so"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/parser/vim.so"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/parser/vim.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/parser/vim.so"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/parser/vim.so"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/parser/vim.so"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/parser/vim.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/after/parser/vim.so"
Searching for "/Users/josh/.config/nvim/after/parser/vim.so"
Searching for "/Users/josh/.local/state/nvim/lazy/readme/parser/vim.so"
Searching for "parser/vimdoc.so" in runtime path
Searching for "/Users/josh/.config/nvim/parser/vimdoc.so"
Searching for "/Users/josh/.local/share/nvim/site/parser/vimdoc.so"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/parser/vimdoc.so"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/parser/vimdoc.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/parser/vimdoc.so"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/parser/vimdoc.so"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/parser/vimdoc.so"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/parser/vimdoc.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/after/parser/vimdoc.so"
Searching for "/Users/josh/.config/nvim/after/parser/vimdoc.so"
Searching for "/Users/josh/.local/state/nvim/lazy/readme/parser/vimdoc.so"
Searching for "parser/query.so" in runtime path
Searching for "/Users/josh/.config/nvim/parser/query.so"
Searching for "/Users/josh/.local/share/nvim/site/parser/query.so"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/parser/query.so"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/parser/query.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/parser/query.so"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/parser/query.so"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/parser/query.so"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/parser/query.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/after/parser/query.so"
Searching for "/Users/josh/.config/nvim/after/parser/query.so"
Searching for "/Users/josh/.local/state/nvim/lazy/readme/parser/query.so"
Searching for "parser/go.so" in runtime path
Searching for "/Users/josh/.config/nvim/parser/go.so"
Searching for "/Users/josh/.local/share/nvim/site/parser/go.so"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/parser/go.so"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/parser/go.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/parser/go.so"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/parser/go.so"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/parser/go.so"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/parser/go.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/parser/go.so"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/parser/go.so"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/after/parser/go.so"
Searching for "/Users/josh/.config/nvim/after/parser/go.so"
Searching for "/Users/josh/.local/state/nvim/lazy/readme/parser/go.so"
finished sourcing /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/nvim-bqf/plugin/bqf.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-bqf/plugin/bqf.vim"
line 1: if exists('g:loaded_bqf')
line 2:     finish
line 3: endif
line 4: 
line 5: let g:loaded_bqf = 1
line 6: 
line 7: com! BqfAutoToggle lua require('bqf').toggleAuto()
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-bqf/plugin/bqf.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/plugin/gitlab.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/plugin/gitlab.vim"
line 1: " gitlab.vim - gitlab support for fugitive.vim
line 2: " Maintainer:   Steven Humphrey <https://github.com/shumphrey>
line 3: " Version:      1.1.1
line 4: 
line 5: " Plugs in to fugitive.vim and provides a gitlab hook for :GBrowse
line 6: " Relies on fugitive.vim by tpope <http://tpo.pe>
line 7: " See fugitive.vim for more details
line 8: " Requires fugitive.vim 3.0 or greater
line 9: "
line 10: " If using https://gitlab.com, everything might just work.
line 11: " If using a private gitlab, you need to specify the gitlab domains for your
line 12: " gitlab instance.
line 13: " e.g.
line 14: "   let g:fugitive_gitlab_domains = ['https://gitlab.mydomain.com']
line 15: "
line 16: " Verified working with current gitlab.com in 2024
line 17: 
line 18: if exists('g:loaded_fugitive_gitlab')
line 19:     finish
line 20: endif
line 21: let g:loaded_fugitive_gitlab = 1
line 22: 
line 23: 
line 24: " Fugitive {{{
line 25: if !exists('g:fugitive_browse_handlers')
line 26:     let g:fugitive_browse_handlers = []
line 27: endif
line 28: 
line 29: if index(g:fugitive_browse_handlers, function('gitlab#fugitive#handler')) < 0
line 30:     call insert(g:fugitive_browse_handlers, function('gitlab#fugitive#handler'))
line 31: endif
line 32: " }}}
line 33: 
line 34: " gitcommit omnicomplete {{{
line 35: function! s:SetUpMessage(filename) abort
line 48: 
line 49: augroup fugitive_gitlab
line 50:     autocmd!
line 51:     if exists('+omnifunc')
line 52:         autocmd FileType gitcommit call s:SetUpMessage(expand('<afile>:p'))
line 53:     endif
line 54:     autocmd BufEnter * if expand('%') ==# '' && &previewwindow && pumvisible() && getbufvar('#', '&omnifunc') ==# 'gitlab#omnifunc#handler' |    setlocal nolist linebreak filetype=markdown | endif
line 58: augroup END
line 59: " }}}
line 60: 
line 61: " vim: set ts=4 sw=4 et foldmethod=marker foldnestmax=1 :
finished sourcing /Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/plugin/gitlab.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim"
line 1: if exists('did_plugin_ultisnips') || &cp
line 2:     finish
line 3: endif
line 4: let did_plugin_ultisnips=1
line 5: 
line 6: if version < 800
line 7:    echohl WarningMsg
line 8:    echom  "UltiSnips requires Vim >= 8.0"
line 9:    echohl None
line 10:    finish
line 11: endif
line 12: 
line 13: " Enable Post debug server config
line 14: if !exists("g:UltiSnipsDebugServerEnable")
line 15:    let g:UltiSnipsDebugServerEnable = 0
line 16: endif
line 17: 
line 18: if !exists("g:UltiSnipsDebugHost")
line 19:    let g:UltiSnipsDebugHost = 'localhost'
line 20: endif
line 21: 
line 22: if !exists("g:UltiSnipsDebugPort")
line 23:    let g:UltiSnipsDebugPort = 8080
line 24: endif
line 25: 
line 26: if !exists("g:UltiSnipsPMDebugBlocking")
line 27:    let g:UltiSnipsPMDebugBlocking = 0
line 28: endif
line 29: 
line 30: 
line 31: " The Commands we define.
line 32: command! -bang -nargs=? -complete=customlist,UltiSnips#FileTypeComplete UltiSnipsEdit :call UltiSnips#Edit(<q-bang>, <q-args>)
line 34: 
line 35: command! -nargs=1 UltiSnipsAddFiletypes :call UltiSnips#AddFiletypes(<q-args>)
line 36: 
line 37: augroup UltiSnips_AutoTrigger
line 38:     au!
line 39:     au InsertCharPre * call UltiSnips#TrackChange()
line 40:     au TextChangedI * call UltiSnips#TrackChange()
line 41:     if exists('##TextChangedP')
line 42:         au TextChangedP * call UltiSnips#TrackChange()
line 43:     endif
line 44: augroup END
line 45: 
line 46: call UltiSnips#map_keys#MapKeys()
Searching for "autoload/UltiSnips/map_keys.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/UltiSnips/map_keys.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/UltiSnips/map_keys.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/UltiSnips/map_keys.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips/map_keys.vim"
line 46: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips/map_keys.vim"
line 1: if exists("b:did_autoload_ultisnips_map_keys")
line 2:    finish
line 3: endif
line 4: let b:did_autoload_ultisnips_map_keys = 1
line 5: 
line 6: " The trigger used to expand a snippet.
line 7: " NOTE: expansion and forward jumping can, but needn't be the same trigger
line 8: if !exists("g:UltiSnipsExpandTrigger")
line 9:     let g:UltiSnipsExpandTrigger = "<tab>"
line 10: endif
line 11: 
line 12: " The trigger used to display all triggers that could possible
line 13: " match in the current position. Use empty to disable.
line 14: if !exists("g:UltiSnipsListSnippets")
line 15:     let g:UltiSnipsListSnippets = "<c-tab>"
line 16: endif
line 17: 
line 18: " The trigger used to jump forward to the next placeholder.
line 19: " NOTE: expansion and forward jumping can be the same trigger.
line 20: if !exists("g:UltiSnipsJumpForwardTrigger")
line 21:     let g:UltiSnipsJumpForwardTrigger = "<c-j>"
line 22: endif
line 23: 
line 24: " The trigger to jump backward inside a snippet
line 25: if !exists("g:UltiSnipsJumpBackwardTrigger")
line 26:     let g:UltiSnipsJumpBackwardTrigger = "<c-k>"
line 27: endif
line 28: 
line 29: " Should UltiSnips unmap select mode mappings automagically?
line 30: if !exists("g:UltiSnipsRemoveSelectModeMappings")
line 31:     let g:UltiSnipsRemoveSelectModeMappings = 1
line 32: end
line 33: 
line 34: " If UltiSnips should remove Mappings, which should be ignored
line 35: if !exists("g:UltiSnipsMappingsToIgnore")
line 36:     let g:UltiSnipsMappingsToIgnore = []
line 37: endif
line 38: 
line 39: " UltiSnipsEdit will use this variable to decide if a new window
line 40: " is opened when editing. default is "normal", allowed are also
line 41: " "tabdo", "vertical", "horizontal", and "context".
line 42: if !exists("g:UltiSnipsEditSplit")
line 43:     let g:UltiSnipsEditSplit = 'normal'
line 44: endif
line 45: 
line 46: " A list of directory names that are searched for snippets.
line 47: if !exists("g:UltiSnipsSnippetDirectories")
line 48:     let g:UltiSnipsSnippetDirectories = [ "UltiSnips" ]
line 49: endif
line 50: 
line 51: " Enable or Disable snipmate snippet expansion.
line 52: if !exists("g:UltiSnipsEnableSnipMate")
line 53:     let g:UltiSnipsEnableSnipMate = 1
line 54: endif
line 55: 
line 56: function! UltiSnips#map_keys#MapKeys() abort
finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips/map_keys.vim
continuing in /Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim
calling UltiSnips#map_keys#MapKeys()

line 1:     if exists("g:UltiSnipsExpandOrJumpTrigger")
line 2:         exec "inoremap <silent> " . g:UltiSnipsExpandOrJumpTrigger . " <C-R>=UltiSnips#ExpandSnippetOrJump()<cr>"
line 3:         exec "snoremap <silent> " . g:UltiSnipsExpandOrJumpTrigger . " <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>"
line 4:     elseif exists("g:UltiSnipsJumpOrExpandTrigger")
line 5:         exec "inoremap <silent> " . g:UltiSnipsJumpOrExpandTrigger . " <C-R>=UltiSnips#JumpOrExpandSnippet()<cr>"
line 6:         exec "snoremap <silent> " . g:UltiSnipsJumpOrExpandTrigger . " <Esc>:call UltiSnips#JumpOrExpandSnippet()<cr>"
line 7:     elseif g:UltiSnipsExpandTrigger == g:UltiSnipsJumpForwardTrigger
line 8:         exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippetOrJump()<cr>"
line 9:         exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>"
line 10:     else
line 11:         exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippet()<cr>"
line 11: inoremap <silent> <tab> <C-R>=UltiSnips#ExpandSnippet()<cr>
line 12:         exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippet()<cr>"
line 12: snoremap <silent> <tab> <Esc>:call UltiSnips#ExpandSnippet()<cr>
line 13:     endif
line 14:     exec "xnoremap <silent> " . g:UltiSnipsExpandTrigger. " :call UltiSnips#SaveLastVisualSelection()<cr>gvs"
line 14: xnoremap <silent> <tab> :call UltiSnips#SaveLastVisualSelection()<cr>gvs
line 15:     if len(g:UltiSnipsListSnippets) > 0
line 16:        exec "inoremap <silent> " . g:UltiSnipsListSnippets . " <C-R>=UltiSnips#ListSnippets()<cr>"
line 16: inoremap <silent> <c-tab> <C-R>=UltiSnips#ListSnippets()<cr>
line 17:        exec "snoremap <silent> " . g:UltiSnipsListSnippets . " <Esc>:call UltiSnips#ListSnippets()<cr>"
line 17: snoremap <silent> <c-tab> <Esc>:call UltiSnips#ListSnippets()<cr>
line 18:     endif
line 19: 
line 20:     snoremap <silent> <BS> <c-g>"_c
line 21:     snoremap <silent> <DEL> <c-g>"_c
line 22:     snoremap <silent> <c-h> <c-g>"_c
line 23:     snoremap <c-r> <c-g>"_c<c-r>
UltiSnips#map_keys#MapKeys returning #0

continuing in /Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim

line 47: 
line 48: " vim: ts=8 sts=4 sw=4
finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/ultisnips/ftdetect/snippets.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/ftdetect/snippets.vim"
line 1: " recognize .snippet files
line 2: if has("autocmd")
line 3:     autocmd BufNewFile,BufRead *.snippets setf snippets
line 4: endif
finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/ftdetect/snippets.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/vim-fugitive/plugin/fugitive.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-fugitive/plugin/fugitive.vim"
line 1: " fugitive.vim - A Git wrapper so awesome, it should be illegal
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      3.7
line 4: " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
line 5: 
line 6: if exists('g:loaded_fugitive')
line 7:   finish
line 8: endif
line 9: let g:loaded_fugitive = 1
line 10: 
line 11: let s:bad_git_dir = '/$\|^fugitive:'
line 12: 
line 13: " FugitiveGitDir() returns the detected Git dir for the given buffer number,
line 14: " or the current buffer if no argument is passed.  This will be an empty
line 15: " string if no Git dir was found.  Use !empty(FugitiveGitDir()) to check if
line 16: " Fugitive is active in the current buffer.  Do not rely on this for direct
line 17: " filesystem access; use FugitiveFind('.git/whatever') instead.
line 18: function! FugitiveGitDir(...) abort
line 47: 
line 48: " FugitiveReal() takes a fugitive:// URL and returns the corresponding path in
line 49: " the work tree.  This may be useful to get a cleaner path for inclusion in
line 50: " the statusline, for example.  Note that the file and its parent directories
line 51: " are not guaranteed to exist.
line 52: "
line 53: " This is intended as an abstract API to be used on any "virtual" path.  For a
line 54: " buffer named foo://bar, check for a function named FooReal(), and if it
line 55: " exists, call FooReal("foo://bar").
line 56: function! FugitiveReal(...) abort
line 70: 
line 71: " FugitiveFind() takes a Fugitive object and returns the appropriate Vim
line 72: " buffer name.  You can use this to generate Fugitive URLs ("HEAD:README") or
line 73: " to get the absolute path to a file in the Git dir (".git/HEAD"), the common
line 74: " dir (".git/config"), or the work tree (":(top)Makefile").
line 75: "
line 76: " An optional second argument provides the Git dir, or the buffer number of a
line 77: " buffer with a Git dir.  The default is the current buffer.
line 78: function! FugitiveFind(...) abort
line 85: 
line 86: " FugitiveParse() takes a fugitive:// URL and returns a 2 element list
line 87: " containing an object name ("commit:file") and the Git dir.  It's effectively
line 88: " the inverse of FugitiveFind().
line 89: function! FugitiveParse(...) abort
line 100: 
line 101: " FugitiveGitVersion() queries the version of Git in use.  Pass up to 3
line 102: " arguments to return a Boolean of whether a certain minimum version is
line 103: " available (FugitiveGitVersion(2,3,4) checks for 2.3.4 or higher) or no
line 104: " arguments to get a raw string.
line 105: function! FugitiveGitVersion(...) abort
line 108: 
line 109: " FugitiveResult() returns an object encapsulating the result of the most
line 110: " recent :Git command.  Will be empty if no result is available.  During a
line 111: " User FugitiveChanged event, this is guaranteed to correspond to the :Git
line 112: " command that triggered the event, or be empty if :Git was not the trigger.
line 113: " Pass in the name of a temp buffer to get the result object for that command
line 114: " instead.  Contains the following keys:
line 115: "
line 116: " * "args": List of command arguments, starting with the subcommand.  Will be
line 117: "   empty for usages like :Git --help.
line 118: " * "git_dir": Git dir of the relevant repository.
line 119: " * "exit_status": The integer exit code of the process.
line 120: " * "flags": Flags passed directly to Git, like -c and --help.
line 121: " * "file": Path to file containing command output.  Not guaranteed to exist,
line 122: "   so verify with filereadable() before trying to access it.
line 123: function! FugitiveResult(...) abort
line 126: 
line 127: " FugitiveExecute() runs Git with a list of arguments and returns a dictionary
line 128: " with the following keys:
line 129: "
line 130: " * "exit_status": The integer exit code of the process.
line 131: " * "stdout": The stdout produced by the process, as a list of lines.
line 132: " * "stderr": The stdout produced by the process, as a list of lines.
line 133: "
line 134: " An optional second argument provides the Git dir, or the buffer number of a
line 135: " buffer with a Git dir.  The default is the current buffer.
line 136: "
line 137: " An optional final argument is a callback Funcref, for asynchronous
line 138: " execution.
line 139: function! FugitiveExecute(args, ...) abort
line 142: 
line 143: " FugitiveShellCommand() turns an array of arguments into a Git command string
line 144: " which can be executed with functions like system() and commands like :!.
line 145: " Integer arguments will be treated as buffer numbers, and the appropriate
line 146: " relative path inserted in their place.
line 147: "
line 148: " An optional second argument provides the Git dir, or the buffer number of a
line 149: " buffer with a Git dir.  The default is the current buffer.
line 150: function! FugitiveShellCommand(...) abort
line 153: 
line 154: " FugitiveConfig() get returns an opaque structure that can be passed to other
line 155: " FugitiveConfig functions in lieu of a Git directory.  This can be faster
line 156: " when performing multiple config queries.  Do not rely on the internal
line 157: " structure of the return value as it is not guaranteed.  If you want a full
line 158: " dictionary of every config value, use FugitiveConfigGetRegexp('.*').
line 159: "
line 160: " An optional argument provides the Git dir, or the buffer number of a
line 161: " buffer with a Git dir.  The default is the current buffer.  Pass a blank
line 162: " string to limit to the global config.
line 163: function! FugitiveConfig(...) abort
line 166: 
line 167: " FugitiveConfigGet() retrieves a Git configuration value.  An optional second
line 168: " argument can be either the object returned by FugitiveConfig(), or a Git
line 169: " dir or buffer number to be passed along to FugitiveConfig().
line 170: function! FugitiveConfigGet(name, ...) abort
line 173: 
line 174: " FugitiveConfigGetAll() is like FugitiveConfigGet() but returns a list of
line 175: " all values.
line 176: function! FugitiveConfigGetAll(name, ...) abort
line 179: 
line 180: " FugitiveConfigGetRegexp() retrieves a dictionary of all configuration values
line 181: " with a key matching the given pattern.  Like git config --get-regexp, but
line 182: " using a Vim regexp.  Second argument has same semantics as
line 183: " FugitiveConfigGet().
line 184: function! FugitiveConfigGetRegexp(pattern, ...) abort
line 187: 
line 188: " FugitiveRemoteUrl() retrieves the remote URL for the given remote name,
line 189: " defaulting to the current branch's remote or "origin" if no argument is
line 190: " given.  Similar to `git remote get-url`, but also attempts to resolve HTTP
line 191: " redirects and SSH host aliases.
line 192: "
line 193: " An optional second argument provides the Git dir, or the buffer number of a
line 194: " buffer with a Git dir.  The default is the current buffer.
line 195: function! FugitiveRemoteUrl(...) abort
line 198: 
line 199: " FugitiveRemote() returns a data structure parsed from the remote URL.
line 200: " For example, for remote URL "https://me@example.com:1234/repo.git", the
line 201: " returned dictionary will contain the following:
line 202: "
line 203: " * "scheme": "https"
line 204: " * "authority": "user@example.com:1234"
line 205: " * "path": "/repo.git" (for SSH URLs this may be a relative path)
line 206: " * "pathname": "/repo.git" (always coerced to absolute path)
line 207: " * "host": "example.com:1234"
line 208: " * "hostname": "example.com"
line 209: " * "port": "1234"
line 210: " * "user": "me"
line 211: " * "path": "/repo.git"
line 212: " * "url": "https://me@example.com:1234/repo.git"
line 213: function! FugitiveRemote(...) abort
line 216: 
line 217: " FugitiveDidChange() triggers a FugitiveChanged event and reloads the summary
line 218: " buffer for the current or given buffer number's repository.  You can also
line 219: " give the result of a FugitiveExecute() and that context will be made
line 220: " available inside the FugitiveChanged() event.
line 221: "
line 222: " Passing the special argument 0 (the number zero) softly expires summary
line 223: " buffers for all repositories.  This can be used after a call to system()
line 224: " with unclear implications.
line 225: function! FugitiveDidChange(...) abort
line 228: 
line 229: " FugitiveHead() retrieves the name of the current branch. If the current HEAD
line 230: " is detached, FugitiveHead() will return the empty string, unless the
line 231: " optional argument is given, in which case the hash of the current commit
line 232: " will be truncated to the given number of characters.
line 233: "
line 234: " An optional second argument provides the Git dir, or the buffer number of a
line 235: " buffer with a Git dir.  The default is the current buffer.
line 236: function! FugitiveHead(...) abort
line 252: 
line 253: function! FugitivePath(...) abort
line 264: 
line 265: function! FugitiveStatusline(...) abort
line 271: 
line 272: let s:resolved_git_dirs = {}
line 273: function! FugitiveActualDir(...) abort
line 283: 
line 284: let s:commondirs = {}
line 285: function! FugitiveCommonDir(...) abort
line 307: 
line 308: function! FugitiveWorkTree(...) abort
line 316: 
line 317: function! FugitiveIsGitDir(...) abort
line 326: 
line 327: function! s:ReadFile(path, line_count) abort
line 337: 
line 338: let s:worktree_for_dir = {}
line 339: let s:dir_for_worktree = {}
line 340: function! s:Tree(path) abort
line 387: 
line 388: function! s:CeilingDirectories() abort
line 404: 
line 405: function! s:ResolveGitDir(git_dir) abort
line 422: 
line 423: function! FugitiveExtractGitDir(path) abort
line 471: 
line 472: function! FugitiveDetect(...) abort
line 484: 
line 485: function! FugitiveGitPath(path) abort
line 488: 
line 489: if exists('+shellslash')
line 490: 
line 491:   function! s:Slash(path) abort
line 494: 
line 495:   function! s:VimSlash(path) abort
line 498: 
line 499:   function FugitiveVimPath(path) abort
line 502: 
line 503: else
line 504: 
line 505:   function! s:Slash(path) abort
line 508: 
line 509:   function! s:VimSlash(path) abort
line 512: 
line 513:   if has('win32unix') && filereadable('/git-bash.exe')
line 514:     function! FugitiveVimPath(path) abort
line 517:   else
line 518:     function! FugitiveVimPath(path) abort
line 521:   endif
line 522: 
line 523: endif
line 524: 
line 525: function! s:ProjectionistDetect() abort
line 542: 
line 543: let s:addr_other = has('patch-8.1.560') || has('nvim-0.5.0') ? '-addr=other' : ''
line 544: let s:addr_tabs  = has('patch-7.4.542') ? '-addr=tabs' : ''
line 545: let s:addr_wins  = has('patch-7.4.542') ? '-addr=windows' : ''
line 546: 
line 547: if exists(':G') != 2
line 548:   command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 549: endif
line 550: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete Git exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 551: 
line 552: if exists(':Gstatus') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 553:   exe 'command! -bang -bar     -range=-1' s:addr_other 'Gstatus exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Gstatus is deprecated in favor of :Git (with no arguments)"|echohl NONE'
line 555: endif
line 556: 
line 557: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 558:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 559:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 562:   endif
line 563: endfor
line 557: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 558:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 559:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 562:   endif
line 563: endfor
line 557: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 558:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 559:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 562:   endif
line 563: endfor
line 557: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 558:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 559:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 562:   endif
line 563: endfor
line 557: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 558:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 559:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 562:   endif
line 563: endfor
line 557: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 558:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 559:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 562:   endif
line 563: endfor
line 557: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 558:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 559:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 562:   endif
line 563: endfor
line 557: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 558:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 559:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 562:   endif
line 563: endfor
line 557: for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
line 558:   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 559:     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|' 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
line 562:   endif
line 563: endfor
line 564: unlet s:cmd
line 565: 
line 566: exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)"
line 566: command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)
line 567: exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)"
line 567: command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)
line 568: 
line 569: exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#GrepCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 569: command! -bang -nargs=? -range=-1 -addr=windows -complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#GrepCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 570: exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#GrepCommand(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", <q-args>)'
line 570: command! -bang -nargs=? -range=-1 -addr=windows -complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#GrepCommand(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", <q-args>)
line 571: 
line 572: exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
line 572: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")
line 573: exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GcLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
line 573: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GcLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")
line 574: exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
line 574: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")
line 575: exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GlLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
line 575: command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GlLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")
line 576: 
line 577: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
line 577: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)
line 578: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
line 578: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)
line 579: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>)'
line 579: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>)
line 580: exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#EditComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>)'
line 580: command! -bar -bang -nargs=* -range=-1 -addr=other -complete=customlist,fugitive#EditComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>)
line 581: exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#EditComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>)'
line 581: command! -bar -bang -nargs=* -range=-1 -addr=other -complete=customlist,fugitive#EditComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>)
line 582: exe 'command! -bar -bang -nargs=* -range=-1' s:addr_tabs  '-complete=customlist,fugitive#EditComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>)'
line 582: command! -bar -bang -nargs=* -range=-1 -addr=tabs -complete=customlist,fugitive#EditComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>)
line 583: exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gdrop    exe fugitive#DropCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 583: command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gdrop    exe fugitive#DropCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 584: 
line 585: if exists(':Gr') != 2
line 586:   exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 586: command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 587: endif
line 588: exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 588: command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 589: 
line 590: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>)'
line 590: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>)
line 591: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>)'
line 591: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>)
line 592: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vertical <mods>", <q-args>)'
line 592: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vertical <mods>", <q-args>)
line 593: 
line 594: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 594: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 595: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 595: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 596: exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 596: command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 597: 
line 598: exe 'command! -bar -bang -nargs=0 GRemove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 598: command! -bar -bang -nargs=0 GRemove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 599: exe 'command! -bar -bang -nargs=0 GUnlink exe fugitive#UnlinkCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 599: command! -bar -bang -nargs=0 GUnlink exe fugitive#UnlinkCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 600: exe 'command! -bar -bang -nargs=0 GDelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 600: command! -bar -bang -nargs=0 GDelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 601: exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject GMove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 601: command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject GMove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 602: exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete GRename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 602: command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete GRename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 603: if exists(':Gremove') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 604:   exe 'command! -bar -bang -nargs=0 Gremove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Gremove is deprecated in favor of :GRemove"|echohl NONE'
line 606: elseif exists(':Gremove') != 2 && !exists('g:fugitive_legacy_commands')
line 607:   exe 'command! -bar -bang -nargs=0 Gremove echoerr ":Gremove has been removed in favor of :GRemove"'
line 607: command! -bar -bang -nargs=0 Gremove echoerr ":Gremove has been removed in favor of :GRemove"
line 608: endif
line 609: if exists(':Gdelete') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 610:   exe 'command! -bar -bang -nargs=0 Gdelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Gdelete is deprecated in favor of :GDelete"|echohl NONE'
line 612: elseif exists(':Gdelete') != 2 && !exists('g:fugitive_legacy_commands')
line 613:   exe 'command! -bar -bang -nargs=0 Gdelete echoerr ":Gdelete has been removed in favor of :GDelete"'
line 613: command! -bar -bang -nargs=0 Gdelete echoerr ":Gdelete has been removed in favor of :GDelete"
line 614: endif
line 615: if exists(':Gmove') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 616:   exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject Gmove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Gmove is deprecated in favor of :GMove"|echohl NONE'
line 618: elseif exists(':Gmove') != 2 && !exists('g:fugitive_legacy_commands')
line 619:   exe 'command! -bar -bang -nargs=? -complete=customlist,fugitive#CompleteObject Gmove' 'echoerr ":Gmove has been removed in favor of :GMove"'
line 619: command! -bar -bang -nargs=? -complete=customlist,fugitive#CompleteObject Gmove echoerr ":Gmove has been removed in favor of :GMove"
line 621: endif
line 622: if exists(':Grename') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 623:   exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete Grename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|echohl WarningMSG|echomsg ":Grename is deprecated in favor of :GRename"|echohl NONE'
line 625: elseif exists(':Grename') != 2 && !exists('g:fugitive_legacy_commands')
line 626:   exe 'command! -bar -bang -nargs=? -complete=customlist,fugitive#RenameComplete Grename' 'echoerr ":Grename has been removed in favor of :GRename"'
line 626: command! -bar -bang -nargs=? -complete=customlist,fugitive#RenameComplete Grename echoerr ":Grename has been removed in favor of :GRename"
line 628: endif
line 629: 
line 630: exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject GBrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
line 630: command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject GBrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
line 631: if exists(':Gbrowse') != 2 && get(g:, 'fugitive_legacy_commands', 0)
line 632:   exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)' '|if <bang>1|redraw!|endif|echohl WarningMSG|echomsg ":Gbrowse is deprecated in favor of :GBrowse"|echohl NONE'
line 634: elseif exists(':Gbrowse') != 2 && !exists('g:fugitive_legacy_commands')
line 635:   exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse' 'echoerr ":Gbrowse has been removed in favor of :GBrowse"'
line 635: command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse echoerr ":Gbrowse has been removed in favor of :GBrowse"
line 637: endif
line 638: 
line 639: if v:version < 704
line 640:   finish
line 641: endif
line 642: 
line 643: let g:io_fugitive = { 'simplify': function('fugitive#simplify'), 'resolve': function('fugitive#resolve'), 'getftime': function('fugitive#getftime'), 'getfsize': function('fugitive#getfsize'), 'getftype': function('fugitive#getftype'), 'filereadable': function('fugitive#filereadable'), 'filewritable': function('fugitive#filewritable'), 'isdirectory': function('fugitive#isdirectory'), 'getfperm': function('fugitive#getfperm'), 'setfperm': function('fugitive#setfperm'), 'readfile': function('fugitive#readfile'), 'writefile': function('fugitive#writefile'), 'glob': function('fugitive#glob'), 'delete': function('fugitive#delete'), 'Real': function('FugitiveReal')}
line 659: 
line 660: augroup fugitive
line 661:   autocmd!
line 662: 
line 663:   autocmd BufNewFile,BufReadPost * if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir |   unlet b:git_dir | endif
line 667:   autocmd FileType           netrw if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir |   unlet b:git_dir | endif
line 671:   autocmd BufFilePost            *  unlet! b:git_dir
line 672: 
line 673:   autocmd FileType git call fugitive#MapCfile()
line 675:   autocmd FileType gitcommit call fugitive#MapCfile('fugitive#MessageCfile()')
line 677:   autocmd FileType git,gitcommit if &foldtext ==# 'foldtext()' |    setlocal foldtext=fugitive#Foldtext() | endif
line 681:   autocmd FileType fugitive call fugitive#MapCfile('fugitive#PorcelainCfile()')
line 683:   autocmd FileType gitrebase let &l:include = '^\%(pick\|squash\|edit\|reword\|fixup\|drop\|[pserfd]\)\>' | if &l:includeexpr !~# 'Fugitive' |   let &l:includeexpr = 'v:fname =~# ''^\x\{4,\}$'' && len(FugitiveGitDir()) ? FugitiveFind(v:fname) : ' .     (len(&l:includeexpr) ? &l:includeexpr : 'v:fname') | endif | let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|setl inex= inc='
line 690: 
line 691:   autocmd BufReadCmd index{,.lock} nested if FugitiveIsGitDir(expand('<amatch>:p:h')) |   let b:git_dir = s:Slash(expand('<amatch>:p:h')) |   exe fugitive#BufReadStatus(v:cmdbang) |   echohl WarningMSG |   echo "fugitive: Direct editing of .git/" . expand('%:t') . " is deprecated" |   echohl NONE | elseif filereadable(expand('<amatch>')) |   silent doautocmd BufReadPre |   keepalt noautocmd read <amatch> |   silent 1delete_ |   silent doautocmd BufReadPost | else |   silent doautocmd BufNewFile | endif
line 706: 
line 707:   autocmd BufReadCmd   fugitive://*          nested exe fugitive#BufReadCmd() | if &path =~# '^\.\%(,\|$\)' |   let &l:path = substitute(&path, '^\.,\=', '', '') | endif
line 711:   autocmd BufWriteCmd  fugitive://*          nested exe fugitive#BufWriteCmd()
line 712:   autocmd FileReadCmd  fugitive://*          nested exe fugitive#FileReadCmd()
line 713:   autocmd FileWriteCmd fugitive://*          nested exe fugitive#FileWriteCmd()
line 714:   if exists('##SourceCmd')
line 715:     autocmd SourceCmd     fugitive://*       nested exe fugitive#SourceCmd()
line 716:   endif
line 717: 
line 718:   autocmd User Flags call Hoist('buffer', function('FugitiveStatusline'))
line 719: 
line 720:   autocmd User ProjectionistDetect call s:ProjectionistDetect()
line 721: augroup END
line 722: 
line 723: nmap <script><silent> <Plug>fugitive:y<C-G> :<C-U>call setreg(v:register, fugitive#Object(@%))<CR>
line 724: nmap <script> <Plug>fugitive: <Nop>
line 725: 
line 726: if get(g:, 'fugitive_no_maps')
line 727:   finish
line 728: endif
line 729: 
line 730: function! s:Map(mode, lhs, rhs, flags) abort
line 752: 
line 753: call s:Map('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')
calling <SNR>43_Map('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')

line 1:   let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>') . '<nowait>'
line 2:   let head = a:lhs
line 3:   let tail = ''
line 4:   let keys = get(g:, a:mode.'remap', {})
line 5:   if len(keys) && type(keys) == type({})
line 6:     while !empty(head)
line 7:       if has_key(keys, head)
line 8:         let head = keys[head]
line 9:         if empty(head)
line 10:           return
line 11:         endif
line 12:         break
line 13:       endif
line 14:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
line 15:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')
line 16:     endwhile
line 17:   endif
line 18:   if empty(mapcheck(head.tail, a:mode))
line 19:     exe a:mode.'map' flags head.tail a:rhs
line 19: cmap <expr><script><nowait> <C-R><C-G> fnameescape(fugitive#Object(@%))
line 20:   endif
<SNR>43_Map returning #0

continuing in /Users/josh/.local/share/nvim/lazy/vim-fugitive/plugin/fugitive.vim

line 754: call s:Map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')
calling <SNR>43_Map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')

line 1:   let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>') . '<nowait>'
line 2:   let head = a:lhs
line 3:   let tail = ''
line 4:   let keys = get(g:, a:mode.'remap', {})
line 5:   if len(keys) && type(keys) == type({})
line 6:     while !empty(head)
line 7:       if has_key(keys, head)
line 8:         let head = keys[head]
line 9:         if empty(head)
line 10:           return
line 11:         endif
line 12:         break
line 13:       endif
line 14:       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
line 15:       let head = substitute(head, '<[^<>]*>$\|.$', '', '')
line 16:     endwhile
line 17:   endif
line 18:   if empty(mapcheck(head.tail, a:mode))
line 19:     exe a:mode.'map' flags head.tail a:rhs
line 19: nmap <silent><script><nowait> y<C-G> :<C-U>call setreg(v:register, fugitive#Object(@%))<CR>
line 20:   endif
<SNR>43_Map returning #0

continuing in /Users/josh/.local/share/nvim/lazy/vim-fugitive/plugin/fugitive.vim

finished sourcing /Users/josh/.local/share/nvim/lazy/vim-fugitive/plugin/fugitive.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/vim-fugitive/ftdetect/fugitive.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-fugitive/ftdetect/fugitive.vim"
line 1: autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame
finished sourcing /Users/josh/.local/share/nvim/lazy/vim-fugitive/ftdetect/fugitive.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/vim-highlightedyank/plugin/highlightedyank.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-highlightedyank/plugin/highlightedyank.vim"
line 1: " highlighted-yank: Make the yanked region apparent!
line 2: " Last Change: 15-Mar-2018.
line 3: " Maintainer : Masaaki Nakamura <mckn@outlook.com>
line 4: 
line 5: " License    : NYSL
line 6: "              Japanese <http://www.kmonos.net/nysl/>
line 7: "              English (Unofficial) <http://www.kmonos.net/nysl/index.en.html>
line 8: if exists("g:loaded_highlightedyank")
line 9:   finish
line 10: endif
line 11: let g:loaded_highlightedyank = 1
line 12: 
line 13: " highlight group
line 14: function! s:default_highlight() abort
line 17: call s:default_highlight()
calling <SNR>47_default_highlight()

line 1:   highlight default link HighlightedyankRegion IncSearch
<SNR>47_default_highlight returning #0

continuing in /Users/josh/.local/share/nvim/lazy/vim-highlightedyank/plugin/highlightedyank.vim

line 18: augroup highlightedyank-event-ColorScheme
line 19:   autocmd!
line 20:   autocmd ColorScheme * call s:default_highlight()
line 21: augroup END
line 22: 
line 23: if exists('##TextYankPost') && !hasmapto('<Plug>(highlightedyank)') && !exists('g:highlightedyank_disable_autocmd')
line 24:   augroup highlightedyank
line 25:     autocmd!
line 26:     autocmd TextYankPost * call highlightedyank#debounce()
line 27:   augroup END
line 28: 
line 29:   " commands
line 30:   command! -nargs=0 -bar HighlightedyankOn     call highlightedyank#on()
line 31:   command! -nargs=0 -bar HighlightedyankOff    call highlightedyank#off()
line 32:   command! -nargs=0 -bar HighlightedyankToggle call highlightedyank#toggle()
line 33: else
line 34:   function! s:keymap() abort
line 47:   call s:keymap()
line 48: 
line 49:   if exists('##OptionSet')
line 50:     augroup highlightedyank-event-OptionSet
line 51:       autocmd!
line 52:       autocmd OptionSet cpoptions call s:keymap()
line 53:     augroup END
line 54:   endif
line 55: 
line 56:   " commands
line 57:   command! -nargs=0 -bar HighlightedyankOn     call highlightedyank#obsolete#highlightedyank#on()
line 58:   command! -nargs=0 -bar HighlightedyankOff    call highlightedyank#obsolete#highlightedyank#off()
line 59:   command! -nargs=0 -bar HighlightedyankToggle call highlightedyank#obsolete#highlightedyank#toggle()
line 60: endif
line 61: 
finished sourcing /Users/josh/.local/share/nvim/lazy/vim-highlightedyank/plugin/highlightedyank.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup lualine | exe "autocmd!" | augroup END
line 1:  exe "autocmd!" | augroup END
line 1: autocmd!
line 1:  augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
Searching for "lua/lualine/themes/papercolor_light.lua" in runtime path
Searching for "/Users/josh/.config/nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/site/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/lualine.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-lspconfig/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-highlightedyank/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/mason.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-fugitive/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/actions-preview.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-navic/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/animation.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/middleclass/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/windows.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-bqf/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/lua/lualine/themes/papercolor_light.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/after/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-bqf/after/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/after/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.config/nvim/after/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/state/nvim/lazy/readme/lua/lualine/themes/papercolor_light.lua"
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_transparent guifg=#e0e2ea guibg=#14161b gui=nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_b_inactive guifg=#4d4d4c guibg=#F5F5F5 gui=nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_c_inactive guifg=#4d4d4c guibg=#F5F5F5 gui=nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_a_inactive guifg=#4d4d4c guibg=#F5F5F5 gui=bold,nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_a_insert guifg=#4271ae guibg=#F5F5F5 gui=bold,nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_b_normal guifg=#efefef guibg=#3e999f gui=nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_c_normal guifg=#efefef guibg=#005f87 gui=nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_a_normal guifg=#4d4d4c guibg=#F5F5F5 gui=bold,nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_a_replace guifg=#F5F5F5 guibg=#d7005f gui=bold,nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: highlight! lualine_a_visual guifg=#F5F5F5 guibg=#d75f00 gui=bold,nocombine
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: autocmd lualine ColorScheme * lua require'lualine'.setup()
line 2:     autocmd lualine OptionSet background lua require'lualine'.setup()
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup lualine_stl_refresh | exe "autocmd!" | augroup END
line 1:  exe "autocmd!" | augroup END
line 1: autocmd!
line 1:  augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: au lualine WinEnter,BufEnter,BufWritePost,SessionLoadPost,FileChangedShellPost,VimResized,Filetype,CursorMoved,CursorMovedI,ModeChanged *
--- Autocommands ---
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: autocmd lualine_stl_refresh WinEnter,BufEnter,BufWritePost,SessionLoadPost,FileChangedShellPost,VimResized,Filetype,CursorMoved,CursorMovedI,ModeChanged * call v:lua.require'lualine'.refresh({'kind': 'tabpage', 'place': ['statusline'], 'trigger': 'autocmd'})
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup lualine_tal_refresh | exe "autocmd!" | augroup END
line 1:  exe "autocmd!" | augroup END
line 1: autocmd!
line 1:  augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup lualine_wb_refresh | exe "autocmd!" | augroup END
line 1:  exe "autocmd!" | augroup END
line 1: autocmd!
line 1:  augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: colorscheme gruvbox
Executing ColorSchemePre Autocommands for "*"
autocommand <Lua 103: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/loader.lua:31>

Executing: 
Searching for "colors/gruvbox.*" in runtime path
Searching for "/Users/josh/.config/nvim/colors/gruvbox.*"
Searching for "/Users/josh/.local/share/nvim/site/colors/gruvbox.*"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/colors/gruvbox.*"
Searching for "/Users/josh/.local/share/nvim/lazy/gruvbox.nvim/colors/gruvbox.*"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/gruvbox.nvim/colors/gruvbox.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/gruvbox.nvim/colors/gruvbox.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
Executing ColorScheme Autocommands for "*"
autocommand <Lua 195: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/highlight.lua:288>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand <Lua 175: ~/.config/nvim/lua/plugins/treesitter.lua:18>

Executing: 
Executing ColorScheme Autocommands for "*"
autocommand call s:default_highlight()

Executing: call s:default_highlight()
calling <SNR>47_default_highlight()

line 1:   highlight default link HighlightedyankRegion IncSearch
<SNR>47_default_highlight returning #0

continuing in ColorScheme Autocommands for "*"

Executing ColorScheme Autocommands for "*"
autocommand lua require'lualine'.setup()

Executing: lua require'lualine'.setup()
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: augroup lualine | exe "autocmd!" | augroup END
line 1:  exe "autocmd!" | augroup END
line 1: autocmd!
line 1:  augroup END
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
Searching for "lua/lualine/themes/papercolor_light.lua" in runtime path
Searching for "/Users/josh/.config/nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/site/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/gruvbox.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.icons/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/oil.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/lualine.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-lspconfig/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-highlightedyank/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/mason.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-fugitive/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/actions-preview.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-navic/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/animation.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/middleclass/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/windows.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-bqf/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/lua/lualine/themes/papercolor_light.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/after/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-bqf/after/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/after/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.config/nvim/after/lua/lualine/themes/papercolor_light.lua"
Searching for "/Users/josh/.local/state/nvim/lazy/readme/lua/lualine/themes/papercolor_light.lua"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_transparent
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_a_visual
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_a_insert
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_b_inactive
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_b_normal
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_a_inactive
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_a_replace
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_c_inactive
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_c_normal
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight clear lualine_a_normal
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_transparent guifg=#ebdbb2 guibg=#282828 gui=nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_b_inactive guifg=#4d4d4c guibg=#F5F5F5 gui=nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_c_inactive guifg=#4d4d4c guibg=#F5F5F5 gui=nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_a_inactive guifg=#4d4d4c guibg=#F5F5F5 gui=bold,nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_a_insert guifg=#4271ae guibg=#F5F5F5 gui=bold,nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_b_normal guifg=#efefef guibg=#3e999f gui=nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_c_normal guifg=#efefef guibg=#005f87 gui=nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_a_normal guifg=#4d4d4c guibg=#F5F5F5 gui=bold,nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_a_replace guifg=#F5F5F5 guibg=#d7005f gui=bold,nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: highlight! lualine_a_visual guifg=#F5F5F5 guibg=#d75f00 gui=bold,nocombine
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: autocmd lualine ColorScheme * lua require'lualine'.setup()
line 2:     autocmd lualine OptionSet background lua require'lualine'.setup()
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: augroup lualine_stl_refresh | exe "autocmd!" | augroup END
line 1:  exe "autocmd!" | augroup END
line 1: autocmd!
line 1:  augroup END
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: au lualine WinEnter,BufEnter,BufWritePost,SessionLoadPost,FileChangedShellPost,VimResized,Filetype,CursorMoved,CursorMovedI,ModeChanged *
--- Autocommands ---
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: autocmd lualine_stl_refresh WinEnter,BufEnter,BufWritePost,SessionLoadPost,FileChangedShellPost,VimResized,Filetype,CursorMoved,CursorMovedI,ModeChanged * call v:lua.require'lualine'.refresh({'kind': 'tabpage', 'place': ['statusline'], 'trigger': 'autocmd'})
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: augroup lualine_tal_refresh | exe "autocmd!" | augroup END
line 1:  exe "autocmd!" | augroup END
line 1: autocmd!
line 1:  augroup END
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
line 1: augroup lualine_wb_refresh | exe "autocmd!" | augroup END
line 1:  exe "autocmd!" | augroup END
line 1: autocmd!
line 1:  augroup END
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
Executing ColorScheme Autocommands for "*"
autocommand <Lua 243: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:949>

Executing: 
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua"
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua:0"
line 1: doautocmd <nomodeline> User CmpReady
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim"
line 1: 
line 2: " Create command for running busted
line 3: command! -nargs=1 -complete=file PlenaryBustedFile lua require('plenary.test_harness').test_file([[<args>]])
line 5: 
line 6: command! -nargs=+ -complete=file PlenaryBustedDirectory lua require('plenary.test_harness').test_directory_command([[<args>]])
line 8: 
line 9: nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>
finished sourcing /Users/josh/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/codeium.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/codeium.vim"
line 1: if exists('g:loaded_codeium')
line 2:   finish
line 3: endif
line 4: let g:loaded_codeium = 1
line 5: 
line 6: command! -nargs=? -complete=customlist,codeium#command#Complete Codeium exe codeium#command#Command(<q-args>)
line 7: 
line 8: if !codeium#util#HasSupportedVersion()
Searching for "autoload/codeium/util.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/codeium/util.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/codeium/util.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/codeium/util.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/plenary.nvim/autoload/codeium/util.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/util.vim"
line 8: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/util.vim"
line 1: function! codeium#util#LineEndingChars(...) abort
line 4: 
line 5: function! codeium#util#HasSupportedVersion() abort
line 11: 
line 12: function! codeium#util#IsUsingRemoteChat() abort
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/util.vim
continuing in /Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/codeium.vim
calling codeium#util#HasSupportedVersion()

line 1:   let s:nvim_virt_text_support = has('nvim-0.6') && exists('*nvim_buf_get_mark')
line 2:   let s:vim_virt_text_support = has('patch-9.0.0185') && has('textprop')
line 3: 
line 4:   return s:nvim_virt_text_support || s:vim_virt_text_support
codeium#util#HasSupportedVersion returning #1

continuing in /Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/codeium.vim

line 9:     finish
line 10: endif
line 11: 
line 12: function! s:SetStyle() abort
line 20: 
line 21: function! s:MapTab() abort
line 26: 
line 27: augroup codeium
line 28:   autocmd!
line 29:   autocmd InsertEnter,CursorMovedI,CompleteChanged * call codeium#DebouncedComplete()
line 30:   autocmd BufEnter     * if codeium#Enabled()|call codeium#command#StartLanguageServer()|endif
line 31:   autocmd BufEnter     * if mode() =~# '^[iR]'|call codeium#DebouncedComplete()|endif
line 32:   autocmd InsertLeave  * call codeium#Clear()
line 33:   autocmd BufLeave     * if mode() =~# '^[iR]'|call codeium#Clear()|endif
line 34: 
line 35:   autocmd ColorScheme,VimEnter * call s:SetStyle()
line 36:   " Map tab using vim enter so it occurs after all other sourcing.
line 37:   autocmd VimEnter             * call s:MapTab()
line 38:   autocmd VimLeave             * call codeium#ServerLeave()
line 39: augroup END
line 40: 
line 41: 
line 42: imap <Plug>(codeium-dismiss)     <Cmd>call codeium#Clear()<CR>
line 43: imap <Plug>(codeium-next)     <Cmd>call codeium#CycleCompletions(1)<CR>
line 44: imap <Plug>(codeium-next-or-complete)     <Cmd>call codeium#CycleOrComplete()<CR>
line 45: imap <Plug>(codeium-previous) <Cmd>call codeium#CycleCompletions(-1)<CR>
line 46: imap <Plug>(codeium-complete)  <Cmd>call codeium#Complete()<CR>
line 47: 
line 48: if !get(g:, 'codeium_disable_bindings')
line 49:   if empty(mapcheck('<C-]>', 'i'))
line 50:     imap <silent><script><nowait><expr> <C-]> codeium#Clear() . "\<C-]>"
line 51:   endif
line 52:   if empty(mapcheck('<M-]>', 'i'))
line 53:     imap <M-]> <Plug>(codeium-next-or-complete)
line 54:   endif
line 55:   if empty(mapcheck('<M-[>', 'i'))
line 56:     imap <M-[> <Plug>(codeium-previous)
line 57:   endif
line 58:   if empty(mapcheck('<M-Bslash>', 'i'))
line 59:     imap <M-Bslash> <Plug>(codeium-complete)
line 60:   endif
line 61:   if empty(mapcheck('<C-k>', 'i'))
line 62:     imap <script><silent><nowait><expr> <C-k> codeium#AcceptNextWord()
line 63:   endif
line 64:   if empty(mapcheck('<C-l>', 'i'))
line 65:     imap <script><silent><nowait><expr> <C-l> codeium#AcceptNextLine()
line 66:   endif
line 67: endif
line 68: 
line 69: call s:SetStyle()
calling <SNR>62_SetStyle()

line 1:   if &t_Co == 256
line 2:     hi def CodeiumSuggestion guifg=#808080 ctermfg=244
line 3:   else
line 4:     hi def CodeiumSuggestion guifg=#808080 ctermfg=8
line 5:   endif
line 6:   hi def link CodeiumAnnotation Normal
<SNR>62_SetStyle returning #0

continuing in /Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/codeium.vim

line 70: 
line 71: let s:dir = expand('<sfile>:h:h')
line 72: if getftime(s:dir . '/doc/codeium.txt') > getftime(s:dir . '/doc/tags')
line 73:   silent! execute 'helptags' fnameescape(s:dir . '/doc')
line 74: endif
line 75: 
line 76: function! CodeiumEnable()  " Enable Codeium if it is disabled
line 80: 
line 81: command! CodeiumEnable :silent! call CodeiumEnable()
line 82: 
line 83: function! CodeiumDisable() " Disable Codeium altogether
line 86: 
line 87: command! CodeiumDisable :silent! call CodeiumDisable()
line 88: 
line 89: function! CodeiumToggle()
line 96: 
line 97: command! CodeiumToggle :silent! call CodeiumToggle()
line 98: 
line 99: function! CodeiumManual() " Disable the automatic triggering of completions
line 102: 
line 103: command! CodeiumManual :silent! call CodeiumManual()
line 104: 
line 105: function! CodeiumAuto()  " Enable the automatic triggering of completions
line 108: 
line 109: command! CodeiumAuto :silent! call CodeiumAuto()
line 110: 
line 111: function! CodeiumChat()
line 114: 
line 115: command! CodeiumChat :silent! call CodeiumChat()
line 116: 
line 117: :amenu Plugin.Codeium.Enable\ \Codeium\ \(\:CodeiumEnable\) :call CodeiumEnable() <Esc>
line 118: :amenu Plugin.Codeium.Disable\ \Codeium\ \(\:CodeiumDisable\) :call CodeiumDisable() <Esc>
line 119: :amenu Plugin.Codeium.Manual\ \Codeium\ \AI\ \Autocompletion\ \(\:CodeiumManual\) :call CodeiumManual() <Esc>
line 120: :amenu Plugin.Codeium.Automatic\ \Codeium\ \AI\ \Completion\ \(\:CodeiumAuto\) :call CodeiumAuto() <Esc>
line 121: :amenu Plugin.Codeium.Toggle\ \Codeium\ \(\:CodeiumToggle\) :call CodeiumToggle() <Esc>
line 122: :amenu Plugin.Codeium.Chat\ \Codeium\ \(\:CodeiumChat\) :call CodeiumChat() <Esc>
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/codeium.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/startuptime.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/startuptime.vim"
line 1: if get(g:, 'loaded_startuptime', 0)
line 2:   finish
line 3: endif
line 4: let g:loaded_startuptime = 1
line 5: 
line 6: let s:save_cpo = &cpo
line 7: set cpo&vim
line 8: 
line 9: if !exists(':StartupTime')
line 10:   command -nargs=* -complete=custom,startuptime#CompleteOptions StartupTime :call startuptime#StartupTime(<q-mods>, <f-args>)
line 12: endif
line 13: 
line 14: " *************************************************
line 15: " * Utils
line 16: " *************************************************
line 17: 
line 18: " Converts 1 and 0 to v:true and v:false.
line 19: function! s:ToBool(x)
line 26: 
line 27: " Returns true if Vim is running on Windows Subsystem for Linux.
line 28: function! s:OnWsl()
line 45: 
line 46: " *************************************************
line 47: " * User Configuration
line 48: " *************************************************
line 49: 
line 50: let g:startuptime_more_info_key_seq =  get(g:, 'startuptime_more_info_key_seq', 'K')
line 52: let g:startuptime_split_edit_key_seq = get(g:, 'startuptime_split_edit_key_seq', 'gf')
line 54: 
line 55: let g:startuptime_exe_path = get(g:, 'startuptime_exe_path', exepath(v:progpath))
line 57: let g:startuptime_exe_args = get(g:, 'startuptime_exe_args', [])
line 59: 
line 60: let g:startuptime_sort = get(g:, 'startuptime_sort', v:true)
line 61: let g:startuptime_tries = get(g:, 'startuptime_tries', 1)
line 62: let g:startuptime_sourcing_events = get(g:, 'startuptime_sourcing_events', v:true)
line 63: let g:startuptime_other_events = get(g:, 'startuptime_other_events', v:true)
line 64: " '--self' was removed, with '--sourced' being used now to control the same
line 65: " setting (but reversed). The following handling allows configurations to
line 66: " continue working if 'startuptime_self' was specified.
line 67: let g:startuptime_self = get(g:, 'startuptime_self', v:false)
line 68: let g:startuptime_sourced = get(g:, 'startuptime_sourced', s:ToBool(!g:startuptime_self))
calling <SNR>65_ToBool(1)

line 1:   if a:x
line 2:     return v:true
<SNR>65_ToBool returning v:true

continuing in /Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/startuptime.vim

line 70: 
line 71: let g:startuptime_startup_indent = get(g:, 'startuptime_startup_indent', 7)
line 73: let g:startuptime_event_width = get(g:, 'startuptime_event_width', 20)
line 75: let g:startuptime_time_width = get(g:, 'startuptime_time_width', 6)
line 77: let g:startuptime_percent_width = get(g:, 'startuptime_percent_width', 7)
line 79: let g:startuptime_plot_width = get(g:, 'startuptime_plot_width', 26)
line 81: 
line 82: let g:startuptime_colorize = get(g:, 'startuptime_colorize', v:true)
line 84: 
line 85: let s:use_blocks = has('multi_byte') && &g:encoding ==# 'utf-8'
line 86: let g:startuptime_use_blocks = get(g:, 'startuptime_use_blocks', s:ToBool(s:use_blocks))
calling <SNR>65_ToBool(1)

line 1:   if a:x
line 2:     return v:true
<SNR>65_ToBool returning v:true

continuing in /Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/startuptime.vim

line 88: " The built-in Windows terminal emulator (used for CMD, Powershell, and WSL)
line 89: " does not properly display some block characters (i.e., the 1/8 precision
line 90: " blocks) using the default font, Consolas. The characters display properly on
line 91: " Cygwin using its default font, Lucida Console, and also when using Consolas.
line 92: let s:win_term = has('win32') || s:OnWsl()
calling <SNR>65_OnWsl()

line 1:   " Recent versions of neovim provide a 'wsl' pseudo-feature.
line 2:   if has('wsl') | return v:true | endif
line 2:  return v:true | endif
line 2:  endif
line 3:   if !has('unix') | return v:false | endif
line 3:  return v:false | endif
line 3:  endif
line 4:   " Read /proc/version instead of using `uname` because 1) it's faster and 2)
line 5:   " so that this works in restricted mode.
line 6:   try
line 7:     if filereadable('/proc/version')
line 8:       let l:version = readfile('/proc/version', '', 1)
line 9:       if len(l:version) ># 0 && stridx(l:version[0], 'Microsoft') ># -1
line 10:         return v:true
line 11:       endif
line 12:     endif
line 13:   catch
line 14:   endtry
line 15:   return v:false
<SNR>65_OnWsl returning v:false

continuing in /Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/startuptime.vim

line 93: let g:startuptime_fine_blocks = get(g:, 'startuptime_fine_blocks', s:ToBool(!s:win_term))
calling <SNR>65_ToBool(1)

line 1:   if a:x
line 2:     return v:true
<SNR>65_ToBool returning v:true

continuing in /Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/startuptime.vim

line 95: 
line 96: let g:startuptime_zero_progress_msg = get(g:, 'startuptime_zero_progress_msg', v:true)
line 98: let g:startuptime_zero_progress_time = get(g:, 'startuptime_zero_progress_time', 2000)
line 100: 
line 101: " The default highlight groups (for colors) are specified below.
line 102: " Change these default colors by defining or linking the corresponding
line 103: " highlight groups.
line 104: " E.g., the following will use the Title highlight for sourcing event text.
line 105: " :highlight link StartupTimeSourcingEvent Title
line 106: " E.g., the following will use custom highlight colors for event times.
line 107: " :highlight StartupTimeTime
line 108: "         \ term=bold ctermfg=12 ctermbg=159 guifg=Blue guibg=LightCyan
line 109: highlight default link StartupTimeStartupKey Normal
line 110: highlight default link StartupTimeStartupValue Title
line 111: highlight default link StartupTimeHeader ModeMsg
line 112: highlight default link StartupTimeSourcingEvent Type
line 113: highlight default link StartupTimeOtherEvent Identifier
line 114: highlight default link StartupTimeTime Directory
line 115: highlight default link StartupTimePercent Special
line 116: highlight default link StartupTimePlot Normal
line 117: 
line 118: let &cpo = s:save_cpo
line 119: unlet s:save_cpo
finished sourcing /Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/startuptime.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/nvim-jdtls/plugin/nvim_jdtls.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/plugin/nvim_jdtls.vim"
line 1: if exists('g:nvim_jdtls')
line 2:   finish
line 3: endif
line 4: let g:nvim_jdtls = 1
line 5: 
line 6: au BufReadCmd jdt://* lua require('jdtls').open_classfile(vim.fn.expand('<amatch>'))
line 7: au BufReadCmd *.class lua require("jdtls").open_classfile(vim.fn.expand("<amatch>"))
line 8: command! JdtWipeDataAndRestart lua require('jdtls.setup').wipe_data_and_restart()
line 9: command! JdtShowLogs lua require('jdtls.setup').show_logs()
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-jdtls/plugin/nvim_jdtls.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/plugin/colorizer.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/plugin/colorizer.vim"
line 1: if exists('g:loaded_colorizer')
line 2:   finish
line 3: endif
line 4: 
line 5: command! ColorizerAttachToBuffer lua require'colorizer'.attach_to_buffer(0)
line 6: command! ColorizerDetachFromBuffer lua require'colorizer'.detach_from_buffer(0)
line 7: command! ColorizerReloadAllBuffers lua require'colorizer'.reload_all_buffers()
line 8: command! ColorizerToggle lua local c = require'colorizer' if c.is_buffer_attached(0) then c.detach_from_buffer(0) else c.attach_to_buffer(0) end
line 11: 
line 12: let g:loaded_colorizer = 1
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/plugin/colorizer.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: augroup ColorizerSetup
line 7: autocmd!
line 7: autocmd FileType * lua COLORIZER_SETUP_HOOK()
line 7: augroup END
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1:   augroup DAPUIRefreshHighlights
line 2:     autocmd!
line 3:     autocmd ColorScheme * lua require('dapui.config.highlights').setup()
line 4:   augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1:   hi default link DapUINormal                  Normal
line 2:   hi default link DapUIVariable                Normal
line 3:   hi default link DapUIScope                   Identifier
line 4:   hi default link DapUIType                    Type
line 5:   hi default link DapUIValue                   Normal
line 6:   hi default link DapUIModifiedValue           Function
line 7:   hi default link DapUIDecoration              Identifier
line 8:   hi default link DapUIThread                  Identifier
line 9:   hi default link DapUIStoppedThread           Function
line 10:   hi default link DapUIFrameName               Normal
line 11:   hi default link DapUISource                  Define
line 12:   hi default link DapUILineNumber              LineNr
line 13:   hi default link DapUIFloatNormal             NormalFloat
line 14:   hi default link DapUIFloatBorder             Identifier
line 15:   hi default link DapUIWatchesEmpty            PreProc
line 16:   hi default link DapUIWatchesValue            Statement
line 17:   hi default link DapUIWatchesError            PreProc
line 18:   hi default link DapUIBreakpointsPath         Identifier
line 19:   hi default link DapUIBreakpointsInfo         Statement
line 20:   hi default link DapUIBreakpointsCurrentLine  CursorLineNr
line 21:   hi default link DapUIBreakpointsLine         DapUILineNumber
line 22:   hi default link DapUIBreakpointsDisabledLine Comment
line 23:   hi default link DapUICurrentFrameName        DapUIBreakpointsCurrentLine
line 24:   hi default link DapUIStepOver                Label
line 25:   hi default link DapUIStepInto                Label
line 26:   hi default link DapUIStepBack                Label
line 27:   hi default link DapUIStepOut                 Label
line 28:   hi default link DapUIStop                    PreProc
line 29:   hi default link DapUIPlayPause               Repeat
line 30:   hi default link DapUIRestart                 Repeat
line 31:   hi default link DapUIUnavailable             Comment
line 32:   hi default link DapUIWinSelect               Special
line 33:   hi default link DapUIEndofBuffer             EndofBuffer
line 34:   
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1:   hi default link DapUINormal                  Normal
line 2:   hi default link DapUIVariable                Normal
line 3:   hi default link DapUIScope                   Identifier
line 4:   hi default link DapUIType                    Type
line 5:   hi default link DapUIValue                   Normal
line 6:   hi default link DapUIModifiedValue           Function
line 7:   hi default link DapUIDecoration              Identifier
line 8:   hi default link DapUIThread                  Identifier
line 9:   hi default link DapUIStoppedThread           Function
line 10:   hi default link DapUIFrameName               Normal
line 11:   hi default link DapUISource                  Define
line 12:   hi default link DapUILineNumber              LineNr
line 13:   hi default link DapUIFloatNormal             NormalFloat
line 14:   hi default link DapUIFloatBorder             Identifier
line 15:   hi default link DapUIWatchesEmpty            PreProc
line 16:   hi default link DapUIWatchesValue            Statement
line 17:   hi default link DapUIWatchesError            PreProc
line 18:   hi default link DapUIBreakpointsPath         Identifier
line 19:   hi default link DapUIBreakpointsInfo         Statement
line 20:   hi default link DapUIBreakpointsCurrentLine  CursorLineNr
line 21:   hi default link DapUIBreakpointsLine         DapUILineNumber
line 22:   hi default link DapUIBreakpointsDisabledLine Comment
line 23:   hi default link DapUICurrentFrameName        DapUIBreakpointsCurrentLine
line 24:   hi default link DapUIStepOver                Label
line 25:   hi default link DapUIStepInto                Label
line 26:   hi default link DapUIStepBack                Label
line 27:   hi default link DapUIStepOut                 Label
line 28:   hi default link DapUIStop                    PreProc
line 29:   hi default link DapUIPlayPause               Repeat
line 30:   hi default link DapUIRestart                 Repeat
line 31:   hi default link DapUIUnavailable             Comment
line 32:   hi default link DapUIWinSelect               Special
line 33:   hi default link DapUIEndofBuffer             EndofBuffer
line 34:   
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/vim-startify/plugin/startify.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-startify/plugin/startify.vim"
line 1: " vim: et sw=2 sts=2
line 2: 
line 3: " Plugin:      https://github.com/mhinz/vim-startify
line 4: " Description: A fancy start screen for Vim.
line 5: " Maintainer:  Marco Hinz <http://github.com/mhinz>
line 6: 
line 7: if exists('g:loaded_startify') || &cp
line 8:   finish
line 9: endif
line 10: let g:loaded_startify = 1
line 11: let g:startify_locked = 0
line 12: 
line 13: if !get(g:, 'startify_disable_at_vimenter') && (!has('nvim') || has('nvim-0.3.5'))
line 14:   " Only for Nvim v0.3.5+: https://github.com/neovim/neovim/issues/9885
line 15:   set shortmess+=I
line 16: endif
line 17: 
line 18: augroup startify
line 19:   autocmd VimEnter    * nested call s:on_vimenter()
line 20:   autocmd VimLeavePre * nested call s:on_vimleavepre()
line 21:   autocmd QuickFixCmdPre  *vimgrep* let g:startify_locked = 1
line 22:   autocmd QuickFixCmdPost *vimgrep* let g:startify_locked = 0
line 23: augroup END
line 24: 
line 25: function! s:update_oldfiles(file)
line 35: 
line 36: function! s:on_vimenter()
line 51: 
line 52: function! s:on_vimleavepre()
line 59: 
line 60: command! -nargs=? -bar -bang -complete=customlist,startify#session_list SLoad   call startify#session_load(<bang>0, <f-args>)
line 61: command! -nargs=? -bar -bang -complete=customlist,startify#session_list SSave   call startify#session_save(<bang>0, <f-args>)
line 62: command! -nargs=? -bar -bang -complete=customlist,startify#session_list SDelete call startify#session_delete(<bang>0, <f-args>)
line 63: command! -nargs=0 -bar SClose call startify#session_close()
line 64: command! -nargs=0 -bar Startify call startify#insane_in_the_membrane(0)
line 65: command! -nargs=0 -bar StartifyDebug call startify#debug()
line 66: 
line 67: nnoremap <silent><plug>(startify-open-buffers) :<c-u>call startify#open_buffers()<cr>
finished sourcing /Users/josh/.local/share/nvim/lazy/vim-startify/plugin/startify.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup filetypedetect
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: augroup END
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/editorconfig.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/editorconfig.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/editorconfig.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/gzip.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2025 Feb 28
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of compressed files
line 10: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 11:   finish
line 12: endif
line 13: let loaded_gzip = 1
line 14: 
line 15: augroup gzip
line 16:   " Remove all gzip autocommands
line 17:   au!
line 18: 
line 19:   " Enable editing of gzipped files.
line 20:   " The functions are defined in autoload/gzip.vim.
line 21:   "
line 22:   " Set binary mode before reading the file.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.bz3,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo,*.lz4 setlocal bin
line 24: 
line 25:   " Use "gzip -d" and similar commands, gunzip isn't always available.
line 26:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 27:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.bz3 call gzip#read("bzip3 -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 30:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 31:   autocmd BufReadPost,FileReadPost^I*.lz4 call gzip#read("lz4 -d -q --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 33:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 34:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 35:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 36:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 37: 
line 38:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 39:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 40:   autocmd BufWritePost,FileWritePost^I*.bz3 call gzip#write("bzip3")
line 41:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 42:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 43:   autocmd BufWritePost,FileWritePost^I*.lz4  call gzip#write("lz4 -q --rm")
line 44:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 45:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 46:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 47:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 48:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 49: 
line 50:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 51:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 52:   autocmd FileAppendPre^I^I^I*.bz3 call gzip#appre("bzip3 -d")
line 53:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 54:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 55:   autocmd FileAppendPre^I^I^I*.lz4 call gzip#appre("lz4 -d -q --rm")
line 56:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 57:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 58:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 59:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 60:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 61: 
line 62:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 63:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 64:   autocmd FileAppendPost^I^I*.bz3 call gzip#write("bzip3")
line 65:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 66:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 67:   autocmd FileAppendPost^I^I*.lz4 call gzip#write("lz4 --rm")
line 68:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 69:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 70:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 71:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 72:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 73: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/gzip.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/man.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/man.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/man.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchit.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchit.vim"
line 1: " Nvim: load the matchit plugin by default.
line 2: if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
line 3:   packadd matchit
Searching for "pack/*/start/matchit" in "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/pack/*/start/matchit"
not found in 'packpath': "pack/*/start/matchit"
Searching for "pack/*/opt/matchit" in "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/pack/*/opt/matchit"
line 3: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim"
line 1: "  matchit.vim: (global plugin) Extended "%" matching
line 2: "  Maintainer:  Christian Brabandt
line 3: "  Version:     1.20
line 4: "  Last Change: 2024 May 20
line 5: "  Repository:  https://github.com/chrisbra/matchit
line 6: "  Previous URL:http://www.vim.org/script.php?script_id=39
line 7: "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
line 8: 
line 9: " Documentation:
line 10: "  The documentation is in a separate file: ../doc/matchit.txt
line 11: 
line 12: " Credits:
line 13: "  Vim editor by Bram Moolenaar (Thanks, Bram!)
line 14: "  Original script and design by Raul Segura Acevedo
line 15: "  Support for comments by Douglas Potts
line 16: "  Support for back references and other improvements by Benji Fisher
line 17: "  Support for many languages by Johannes Zellner
line 18: "  Suggestions for improvement, bug reports, and support for additional
line 19: "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
line 20: "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
line 21: 
line 22: " Debugging:
line 23: "  If you'd like to try the built-in debugging commands...
line 24: "   :MatchDebug      to activate debugging for the current buffer
line 25: "  This saves the values of several key script variables as buffer-local
line 26: "  variables.  See the MatchDebug() function, below, for details.
line 27: 
line 28: " TODO:  I should think about multi-line patterns for b:match_words.
line 29: "   This would require an option:  how many lines to scan (default 1).
line 30: "   This would be useful for Python, maybe also for *ML.
line 31: " TODO:  Maybe I should add a menu so that people will actually use some of
line 32: "   the features that I have implemented.
line 33: " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
line 34: "   Match_wrapper() instead.
line 35: " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
line 36: " TODO:  Make backrefs safer by using '\V' (very no-magic).
line 37: " TODO:  Add a level of indirection, so that custom % scripts can use my
line 38: "   work but extend it.
line 39: 
line 40: " Allow user to prevent loading and prevent duplicate loading.
line 41: if exists("g:loaded_matchit") || &cp
line 42:   finish
line 43: endif
line 44: let g:loaded_matchit = 1
line 45: 
line 46: let s:save_cpo = &cpo
line 47: set cpo&vim
line 48: 
line 49: fun MatchEnable()
line 89: 
line 90: fun MatchDisable()
line 108: 
line 109: " Call this function to turn on debugging information.  Every time the main
line 110: " script is run, buffer variables will be saved.  These can be used directly
line 111: " or viewed using the menu items below.
line 112: if !exists(":MatchDebug")
line 113:   command! -nargs=0 MatchDebug call matchit#Match_debug()
line 114: endif
line 115: if !exists(":MatchDisable")
line 116:   command! -nargs=0 MatchDisable :call MatchDisable()
line 117: endif
line 118: if !exists(":MatchEnable")
line 119:   command! -nargs=0 MatchEnable :call MatchEnable()
line 120: endif
line 121: 
line 122: call MatchEnable()
calling MatchEnable()

line 1:   nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
line 2:   nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
line 3:   xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
line 5:   xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
line 6:   onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
line 7:   onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
line 8: 
line 9:   " Analogues of [{ and ]} using matching patterns:
line 10:   nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
line 11:   nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
line 12:   xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
line 13:   xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
line 14:   onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
line 15:   onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
line 16: 
line 17:   " text object:
line 18:   xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
line 19: 
line 20:   if !exists("g:no_plugin_maps")
line 21:     nmap <silent> %  <Plug>(MatchitNormalForward)
line 22:     nmap <silent> g% <Plug>(MatchitNormalBackward)
line 23:     xmap <silent> %  <Plug>(MatchitVisualForward)
line 24:     xmap <silent> g% <Plug>(MatchitVisualBackward)
line 25:     omap <silent> %  <Plug>(MatchitOperationForward)
line 26:     omap <silent> g% <Plug>(MatchitOperationBackward)
line 27: 
line 28:     " Analogues of [{ and ]} using matching patterns:
line 29:     nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
line 30:     nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
line 31:     xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
line 32:     xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
line 33:     omap <silent> [% <Plug>(MatchitOperationMultiBackward)
line 34:     omap <silent> ]% <Plug>(MatchitOperationMultiForward)
line 35: 
line 36:     " Text object
line 37:     xmap a% <Plug>(MatchitVisualTextObject)
line 38:   endif
MatchEnable returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim

line 123: 
line 124: let &cpo = s:save_cpo
line 125: unlet s:save_cpo
line 126: 
line 127: " vim:sts=2:sw=2:et:
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchit.vim
line 3: augroup filetypedetect
line 3: augroup END
line 4: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchit.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchparen.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2025 Mar 14
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded (or disabled)
line 8: " - when 'compatible' is set
line 9: " - Vim has no support for :defer
line 10: if exists("g:loaded_matchparen") || &cp || exists(":defer") != 2
line 12:   finish
line 13: endif
line 14: let g:loaded_matchparen = 1
line 15: 
line 16: if !exists("g:matchparen_timeout")
line 17:   let g:matchparen_timeout = 300
line 18: endif
line 19: if !exists("g:matchparen_insert_timeout")
line 20:   let g:matchparen_insert_timeout = 60
line 21: endif
line 22: if !exists("g:matchparen_disable_cursor_hl")
line 23:   let g:matchparen_disable_cursor_hl = 0
line 24: endif
line 25: 
line 26: augroup matchparen
line 27:   " Replace all matchparen autocommands
line 28:   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 29:   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
line 30:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
line 31:   autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 32:   autocmd! TextChangedP * call s:Remove_Matches()
line 33: augroup END
line 34: 
line 35: " Skip the rest if it was already done.
line 36: if exists("*s:Highlight_Matching_Pair")
line 37:   finish
line 38: endif
line 39: 
line 40: let s:cpo_save = &cpo
line 41: set cpo-=C
line 42: 
line 43: " The function that is invoked (very often) to define a ":match" highlighting
line 44: " for any matching paren.
line 45: func s:Highlight_Matching_Pair()
line 202: 
line 203: func s:Remove_Matches()
line 211: 
line 212: " Define commands that will disable and enable the plugin.
line 213: command DoMatchParen call s:DoMatchParen()
line 214: command NoMatchParen call s:NoMatchParen()
line 215: 
line 216: func s:NoMatchParen()
line 223: 
line 224: func s:DoMatchParen()
line 230: 
line 231: let &cpo = s:cpo_save
line 232: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchparen.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/netrwPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/netrwPlugin.vim"
line 1: " Load the netrw package.
line 2: 
line 3: if &cp || exists("g:loaded_netrw") || exists("g:loaded_netrwPlugin")
line 4:   finish
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/netrwPlugin.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/osc52.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/osc52.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/osc52.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/rplugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/rplugin.vim"
line 1: if exists('g:loaded_remote_plugins')
line 2:   finish
line 3: endif
line 4: let g:loaded_remote_plugins = '/path/to/manifest'
line 5: 
line 6: " Get the path to the rplugin manifest file.
line 7: function! s:GetManifestPath() abort
line 26: 
line 27: " Old manifest file based on known script locations.
line 28: function! s:GetOldManifestPaths() abort
line 43: 
line 44: function! s:GetManifest() abort
line 57: 
line 58: function! s:LoadRemotePlugins() abort
line 64: 
line 65: command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
line 66: 
line 67: if index(v:argv, "--clean") < 0
line 68:   call s:LoadRemotePlugins()
calling <SNR>87_LoadRemotePlugins()

line 1:   let g:loaded_remote_plugins = s:GetManifest()
calling <SNR>87_GetManifest()

line 1:   let manifest = s:GetManifestPath()
calling <SNR>87_GetManifestPath()

line 1:   let manifest_base = ''
line 2: 
line 3:   if exists('$NVIM_RPLUGIN_MANIFEST')
line 4:     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
line 5:   endif
line 6: 
line 7:   let dest = stdpath('data')
line 8:   if !empty(dest)
line 9:     if !isdirectory(dest)
line 10:       if getftype(dest) != "link"
line 11:         call mkdir(dest, 'p', 0700)
line 12:       endif
line 13:     endif
line 14:     let manifest_base = dest
line 15:   endif
line 16: 
line 17:   return manifest_base.'/rplugin.vim'
<SNR>87_GetManifestPath returning '/Users/josh/.local/share/nvim/rplugin.vim'

continuing in <SNR>87_GetManifest

line 2:   if !filereadable(manifest)
line 3:     " Check if an old manifest file exists and move it to the new location.
line 4:     for old_manifest in s:GetOldManifestPaths()
calling <SNR>87_GetOldManifestPaths()

line 1:   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
line 4:   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
line 6:   if !has('win32')
line 7:     return [origpath]
<SNR>87_GetOldManifestPaths returning ['/Users/josh/.config/nvim/.init.vim-rplugin~']

continuing in <SNR>87_GetManifest

line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 4:     for old_manifest in s:GetOldManifestPaths()
line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 10:   endif
line 11:   return manifest
<SNR>87_GetManifest returning '/Users/josh/.local/share/nvim/rplugin.vim'

continuing in <SNR>87_LoadRemotePlugins

line 2:   if filereadable(g:loaded_remote_plugins)
line 3:     execute 'source' fnameescape(g:loaded_remote_plugins)
line 4:   endif
<SNR>87_LoadRemotePlugins returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/rplugin.vim

line 69: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/rplugin.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/shada.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/shada.vim"
line 1: if exists('g:loaded_shada_plugin')
line 2:   finish
line 3: endif
line 4: let g:loaded_shada_plugin = 1
line 5: 
line 6: augroup ShaDaCommands
line 7:   autocmd!
line 8:   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b'))) |setlocal filetype=shada
line 12:   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
line 15:   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |if writefile(shada#get_binstrings(getline(1, '$')),expand('<afile>'), 'b') == 0 |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))? 0: stridx(&cpoptions, '+') != -1) |endif
line 23:   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'b')
line 30:   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'ab')
line 37:   autocmd SourceCmd *.shada,*.shada.tmp.[a-z] :execute 'rshada' fnameescape(expand('<afile>'))
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/shada.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/spellfile.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: 
line 3: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 4:   finish
line 5: endif
line 6: let loaded_spellfile_plugin = 1
line 7: 
line 8: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/spellfile.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tarPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: "
line 3: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 4: " Modified by Charles E. Campbell
line 5: " Distributed under the GNU General Public License.
line 6: "
line 7: " Updates are available from <http://michael.toren.net/code/>.  If you
line 8: " find this script useful, or have suggestions for improvements, please
line 9: " let me know.
line 10: " Also look there for further comments and documentation.
line 11: "
line 12: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 13: " ---------------------------------------------------------------------
line 14: "  Load Once: {{{1
line 15: if &cp || exists("g:loaded_tarPlugin")
line 16:  finish
line 17: endif
line 18: let g:loaded_tarPlugin = "v32"
line 19: let s:keepcpo          = &cpo
line 20: set cpo&vim
line 21: 
line 22: " ---------------------------------------------------------------------
line 23: "  Public Interface: {{{1
line 24: augroup tar
line 25:   au!
line 26:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 27:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 28:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 30: 
line 31:   if has("unix")
line 32:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 33:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 34:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 36:   endif
line 37: 
line 38:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.bz3^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tar.lz4^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^I^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 49:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 50:   au BufReadCmd   *.tlz4^I^Icall tar#Browse(expand("<amatch>"))
line 51:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 52:   au BufReadCmd   *.tzst^I^Icall tar#Browse(expand("<amatch>"))
line 53: augroup END
line 54: 
line 55: " ---------------------------------------------------------------------
line 56: " Restoration And Modelines: {{{1
line 57: " vim: fdm=marker
line 58: let &cpo= s:keepcpo
line 59: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tarPlugin.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tohtml.lua
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tohtml.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tohtml.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tutor.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tutor.vim"
line 1: " Tutor:^INew Style Tutor Plugin :h vim-tutor-mode
line 2: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 3: " Contributors:^IPhm Bnh An <phambinhanctb2004@gmail.com>
line 4: " Original Author: Felipe Morales <hel.sheep@gmail.com>
line 5: " Date: 2025 May 12
line 6: 
line 7: if exists('g:loaded_tutor_mode_plugin') || &compatible
line 8:     finish
line 9: endif
line 10: let g:loaded_tutor_mode_plugin = 1
line 11: 
line 12: command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tutor.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/zipPlugin.vim
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IDec 07, 2021
line 4: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 5: " Former Maintainer:^ICharles E Campbell
line 6: " License:^I^IVim License  (see vim's :help license)
line 7: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 8: "               Permission is hereby granted to use and distribute this code,
line 9: "               with or without modifications, provided that this copyright
line 10: "               notice is copied with it. Like anything else that's free,
line 11: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 12: "               of any kind, either expressed or implied. By using this
line 13: "               plugin, you agree that in no event will the copyright
line 14: "               holder be liable for any damages resulting from the use
line 15: "               of this software.
line 16: "
line 17: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 18: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 19: " ---------------------------------------------------------------------
line 20: " Load Once: {{{1
line 21: if &cp || exists("g:loaded_zipPlugin")
line 22:  finish
line 23: endif
line 24: let g:loaded_zipPlugin = "v33"
line 25: let s:keepcpo          = &cpo
line 26: set cpo&vim
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Options: {{{1
line 30: if !exists("g:zipPlugin_ext")
line 31:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 32: endif
line 33: 
line 34: " ---------------------------------------------------------------------
line 35: " Public Interface: {{{1
line 36: augroup zip
line 37:  au!
line 38:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 39:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 40:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 42: 
line 43:  if has("unix")
line 44:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 45:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 46:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 48:  endif
line 49: 
line 50:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 50: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 51: augroup END
line 52: 
line 53: " ---------------------------------------------------------------------
line 54: "  Restoration And Modelines: {{{1
line 55: "  vim: fdm=marker
line 56: let &cpo= s:keepcpo
line 57: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/zipPlugin.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/cmp-buffer/after/plugin/cmp_buffer.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-buffer/after/plugin/cmp_buffer.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-buffer/after/plugin/cmp_buffer.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua"
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0"
line 1: runtime! plugin/UltiSnips.vim
Searching for "plugin/UltiSnips.vim" in runtime path
Searching for "/Users/josh/.config/nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/site/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startify/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/which-key.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/claude-code.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-go/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-nio/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-ui/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/plenary.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/gruvbox.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.icons/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/oil.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lualine.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-lspconfig/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-highlightedyank/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mason.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-fugitive/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/actions-preview.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-navic/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim"
line 1: if exists('did_plugin_ultisnips') || &cp
line 2:     finish
finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim
continuing in nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
Searching for "/Users/josh/.local/share/nvim/lazy/animation.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/middleclass/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/windows.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-bqf/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/plugin/UltiSnips.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/UltiSnips.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/pack/dist/opt/matchit/plugin/UltiSnips.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/lib/nvim/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/after/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/after/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/after/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-bqf/after/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/after/plugin/UltiSnips.vim"
Searching for "/Users/josh/.config/nvim/after/plugin/UltiSnips.vim"
Searching for "/Users/josh/.local/state/nvim/lazy/readme/plugin/UltiSnips.vim"
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0"
line 1: py3 import ultisnips_utils
Searching for "autoload/provider/python3.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startify/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/which-key.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/claude-code.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-go/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-nio/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-ui/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startuptime/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/plenary.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-cmp/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/gruvbox.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.icons/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/oil.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lualine.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-lspconfig/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-highlightedyank/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mason.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-fugitive/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/actions-preview.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-navic/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/animation.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/middleclass/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/windows.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-bqf/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/autoload/provider/python3.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/autoload/provider/python3.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider/python3.vim"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider/python3.vim"
line 1: if exists('g:loaded_python3_provider')
line 2:   finish
line 3: endif
line 4: 
line 5: function! provider#python3#Call(method, args) abort
line 8: 
line 9: function! provider#python3#Require(host) abort
line 12: 
line 13: let s:prog = v:lua.vim.provider.python.detect_by_module('neovim')
line 14: let g:loaded_python3_provider = empty(s:prog) ? 0 : 2
line 15: call v:lua.require'vim.provider.python'.start()
Searching for "autoload/remote/host.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startify/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/which-key.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/claude-code.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-go/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-nio/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-ui/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startuptime/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/plenary.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-cmp/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/gruvbox.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.icons/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/oil.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lualine.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-lspconfig/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-highlightedyank/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mason.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-fugitive/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/actions-preview.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-navic/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/animation.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/middleclass/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/windows.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-bqf/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/autoload/remote/host.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/autoload/remote/host.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/remote/host.vim"
line 15: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/remote/host.vim"
line 1: let s:hosts = {}
line 2: let s:plugin_patterns = {}
line 3: let s:plugins_for_host = {}
line 4: 
line 5: " Register a host by associating it with a factory(funcref)
line 6: function! remote#host#Register(name, pattern, factory) abort
line 14: 
line 15: " Register a clone to an existing host. The new host will use the same factory
line 16: " as `source`, but it will run as a different process. This can be used by
line 17: " plugins that should run isolated from other plugins created for the same host
line 18: " type
line 19: function! remote#host#RegisterClone(name, orig_name) abort
line 31: 
line 32: " Get a host channel, bootstrapping it if necessary
line 33: function! remote#host#Require(name) abort
line 48: 
line 49: function! remote#host#IsRunning(name) abort
line 55: 
line 56: " Example of registering a Python plugin with two commands (one async), one
line 57: " autocmd (async) and one function (sync):
line 58: "
line 59: " let s:plugin_path = expand('<sfile>:p:h').'/nvim_plugin.py'
line 60: " call remote#host#RegisterPlugin('python', s:plugin_path, [
line 61: "   \ {'type': 'command', 'name': 'PyCmd', 'sync': 1, 'opts': {}},
line 62: "   \ {'type': 'command', 'name': 'PyAsyncCmd', 'sync': 0, 'opts': {'eval': 'cursor()'}},
line 63: "   \ {'type': 'autocmd', 'name': 'BufEnter', 'sync': 0, 'opts': {'eval': 'expand("<afile>")'}},
line 64: "   \ {'type': 'function', 'name': 'PyFunc', 'sync': 1, 'opts': {}}
line 65: "   \ ])
line 66: "
line 67: " The third item in a declaration is a boolean: non zero means the command,
line 68: " autocommand or function will be executed synchronously with rpcrequest.
line 69: function! remote#host#RegisterPlugin(host, path, specs) abort
line 111: 
line 112: function! s:RegistrationCommands(host) abort
line 155: 
line 156: function! remote#host#UpdateRemotePlugins() abort
line 176: 
line 177: function! remote#host#PluginsForHost(host) abort
line 183: 
line 184: function! remote#host#LoadErrorForHost(host, log) abort
line 190: 
line 191: " Registration of standard hosts
line 192: 
line 193: " Python3
line 194: call remote#host#Register('python3', '*', function('provider#python3#Require'))
calling remote#host#Register('python3', '*', function('provider#python3#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
line 2:   let s:plugin_patterns[a:name] = a:pattern
line 3:   if type(a:factory) == type(1) && a:factory
line 4:     " Passed a channel directly
line 5:     let s:hosts[a:name].channel = a:factory
line 6:   endif
remote#host#Register returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/remote/host.vim

line 196: 
line 197: " Ruby
line 198: call remote#host#Register('ruby', '*.rb', function('provider#ruby#Require'))
calling remote#host#Register('ruby', '*.rb', function('provider#ruby#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
line 2:   let s:plugin_patterns[a:name] = a:pattern
line 3:   if type(a:factory) == type(1) && a:factory
line 4:     " Passed a channel directly
line 5:     let s:hosts[a:name].channel = a:factory
line 6:   endif
remote#host#Register returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/remote/host.vim

line 200: 
line 201: " nodejs
line 202: call remote#host#Register('node', '*', function('provider#node#Require'))
calling remote#host#Register('node', '*', function('provider#node#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
line 2:   let s:plugin_patterns[a:name] = a:pattern
line 3:   if type(a:factory) == type(1) && a:factory
line 4:     " Passed a channel directly
line 5:     let s:hosts[a:name].channel = a:factory
line 6:   endif
remote#host#Register returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/remote/host.vim

line 204: 
line 205: " perl
line 206: call remote#host#Register('perl', '*', function('provider#perl#Require'))
calling remote#host#Register('perl', '*', function('provider#perl#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
line 2:   let s:plugin_patterns[a:name] = a:pattern
line 3:   if type(a:factory) == type(1) && a:factory
line 4:     " Passed a channel directly
line 5:     let s:hosts[a:name].channel = a:factory
line 6:   endif
remote#host#Register returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/remote/host.vim

finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/remote/host.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider/python3.vim
calling remote#host#RegisterClone('legacy-python3-provider', 'python3')

line 1:   if !has_key(s:hosts, a:orig_name)
line 2:     throw 'No host named "'.a:orig_name.'" is registered'
line 3:   endif
line 4:   let Factory = s:hosts[a:orig_name].factory
line 5:   let s:hosts[a:name] = { 'factory': Factory, 'channel': 0, 'initialized': 0, 'orig_name': a:orig_name }
remote#host#RegisterClone returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider/python3.vim

calling remote#host#RegisterPlugin('legacy-python3-provider', 'script_host.py', [])

line 1:   let plugins = remote#host#PluginsForHost(a:host)
calling remote#host#PluginsForHost('legacy-python3-provider')

line 1:   if !has_key(s:plugins_for_host, a:host)
line 2:     let s:plugins_for_host[a:host] = []
line 3:   end
line 4:   return s:plugins_for_host[a:host]
remote#host#PluginsForHost returning []

continuing in remote#host#RegisterPlugin

line 2: 
line 3:   for plugin in plugins
line 4:     if plugin.path == a:path
line 5:       throw 'Plugin "'.a:path.'" is already registered'
line 6:     endif
line 7:   endfor
line 8: 
line 9:   if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
calling remote#host#IsRunning('legacy-python3-provider')

line 1:   if !has_key(s:hosts, a:name)
line 2:     throw 'No host named "'.a:name.'" is registered'
line 3:   endif
line 4:   return s:hosts[a:name].channel != 0
remote#host#IsRunning returning #0

continuing in remote#host#RegisterPlugin

line 10:     " For now we won't allow registration of plugins when the host is already
line 11:     " running.
line 12:     throw 'Host "'.a:host.'" is already running'
line 13:   endif
line 14: 
line 15:   for spec in a:specs
line 16:     let type = spec.type
line 17:     let name = spec.name
line 18:     let sync = spec.sync
line 19:     let opts = spec.opts
line 20:     let rpc_method = a:path
line 21:     if type == 'command'
line 22:       let rpc_method .= ':command:'.name
line 23:       call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
line 24:     elseif type == 'autocmd'
line 25:       " Since multiple handlers can be attached to the same autocmd event by a
line 26:       " single plugin, we need a way to uniquely identify the rpc method to
line 27:       " call.  The solution is to append the autocmd pattern to the method
line 28:       " name(This still has a limit: one handler per event/pattern combo, but
line 29:       " there's no need to allow plugins define multiple handlers in that case)
line 30:       let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
line 31:       call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
line 32:     elseif type == 'function'
line 33:       let rpc_method .= ':function:'.name
line 34:       call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
line 35:     else
line 36:       echoerr 'Invalid declaration type: '.type
line 37:     endif
line 38:   endfor
line 39: 
line 40:   call add(plugins, {'path': a:path, 'specs': a:specs})
remote#host#RegisterPlugin returning #0

continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider/python3.vim

finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider/python3.vim
continuing in nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
calling provider#python3#Call('execute', ['import ultisnips_utils', 1, 1])

line 1:   return v:lua.vim.provider.python.call(a:method, a:args)
calling remote#host#Require('legacy-python3-provider')

line 1:   if !has_key(s:hosts, a:name)
line 2:     throw 'No host named "'.a:name.'" is registered'
line 3:   endif
line 4:   let host = s:hosts[a:name]
line 5:   if !host.channel && !host.initialized
line 6:     let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
line 10:     let host.channel = call(host.factory, [host_info])
calling provider#python3#Require({'orig_name': 'python3', 'name': 'legacy-python3-provider'})

line 1:   return v:lua.vim.provider.python.require(a:host)
calling remote#host#PluginsForHost('legacy-python3-provider')

line 1:   if !has_key(s:plugins_for_host, a:host)
line 2:     let s:plugins_for_host[a:host] = []
line 3:   end
line 4:   return s:plugins_for_host[a:host]
remote#host#PluginsForHost returning [{'specs': [], 'path': 'script_host.py'}]

continuing in provider#python3#Require

Searching for "autoload/provider.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startify/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/which-key.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/claude-code.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-go/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-nio/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-ui/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startuptime/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/plenary.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-cmp/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/gruvbox.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.icons/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/oil.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lualine.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-lspconfig/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-highlightedyank/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mason.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-fugitive/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/actions-preview.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-navic/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/ultisnips/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/animation.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/middleclass/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/windows.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-bqf/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/playground/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/mini.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/autoload/provider.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/snacks.nvim/autoload/provider.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider.vim"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider.vim"
line 1: " Common functions for providers
line 2: 
line 3: " Start the provider and perform a 'poll' request
line 4: "
line 5: " Returns a valid channel on success
line 6: function! provider#Poll(argv, orig_name, log_env, ...) abort
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider.vim
continuing in provider#python3#Require
calling provider#Poll(['python3.12', '-c', 'import sys; sys....neovim.start_host()', 'script_host.py'], 'python3', '$NVIM_PYTHON_LOG_FILE', {'overlapped': v:true})

line 1:   let job = {'rpc': v:true, 'stderr_buffered': v:true}
line 2:   if a:0
line 3:     let job = extend(job, a:1)
line 4:   endif
line 5:   try
line 6:     let channel_id = jobstart(a:argv, job)
line 7:     if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
line 8:       return channel_id
:return 3 made pending

line 9:     endif
line 10:   catch
line 11:     echomsg v:throwpoint
line 12:     echomsg v:exception
line 13:     for row in get(job, 'stderr', [])
line 14:       echomsg row
line 15:     endfor
line 16:   endtry
:return 3 resumed

provider#Poll returning #3

continuing in provider#python3#Require

provider#python3#Require returning #3

continuing in remote#host#Require

line 11:     let host.initialized = 1
line 12:   endif
line 13:   return host.channel
remote#host#Require returning #3

continuing in provider#python3#Call

line 1: au DirChanged * call rpcnotify(3, "python_chdir", v:event.cwd)
line 1: call rpcnotify(3, "python_chdir", getcwd())
provider#python3#Call returning v:null

continuing in nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0

finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
Searching for "autoload/cmp_nvim_ultisnips.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startify/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/which-key.nvim/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/claude-code.nvim/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-go/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-nio/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-ui/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startuptime/autoload/cmp_nvim_ultisnips.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/cmp_nvim_ultisnips.vim"
line 0: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/cmp_nvim_ultisnips.vim"
line 1: function! cmp_nvim_ultisnips#setup_treesitter_autocmds()
line 8: 
line 9: function! cmp_nvim_ultisnips#initCustomUltiSnipMappings()
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/cmp_nvim_ultisnips.vim
continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
calling cmp_nvim_ultisnips#setup_treesitter_autocmds()

line 1:   augroup cmp_nvim_ultisnips
line 2:     autocmd!
line 3:     autocmd TextChangedI,TextChangedP * lua require("cmp_nvim_ultisnips.treesitter").set_filetype()
line 4:     autocmd InsertLeave * lua require("cmp_nvim_ultisnips.treesitter").reset_filetype()
line 5:   augroup end
cmp_nvim_ultisnips#setup_treesitter_autocmds returning #0

continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua

calling cmp_nvim_ultisnips#initCustomUltiSnipMappings()

line 1:   " Define silent mappings
line 2: 
line 3:   " More info on why CursorMoved is called can be found here:
line 4:   " https://github.com/SirVer/ultisnips/issues/1295#issuecomment-774056584
line 5:   imap <silent> <Plug>(cmpu-expand) <C-r>=[UltiSnips#CursorMoved(), UltiSnips#ExpandSnippet()][1]<cr>
line 7: 
line 8:   smap <silent> <Plug>(cmpu-expand) <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>
line 10: 
line 11:   imap <silent> <Plug>(cmpu-jump-forwards) <C-r>=UltiSnips#JumpForwards()<cr>
line 13: 
line 14:   smap <silent> <Plug>(cmpu-jump-forwards) <Esc>:call UltiSnips#JumpForwards()<cr>
line 16: 
line 17:   imap <silent> <Plug>(cmpu-jump-backwards) <C-r>=UltiSnips#JumpBackwards()<cr>
line 19: 
line 20:   smap <silent> <Plug>(cmpu-jump-backwards) <Esc>:call UltiSnips#JumpBackwards()<cr>
cmp_nvim_ultisnips#initCustomUltiSnipMappings returning #0

continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua

line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0"
line 1: command! -nargs=0 CmpUltisnipsReloadSnippets lua require('cmp_nvim_ultisnips').reload_snippets()
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: source /Users/josh/.local/share/nvim/lazy/ultisnips/after/plugin/UltiSnips_after.vim
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/after/plugin/UltiSnips_after.vim"
line 1: " Called after everything else to reclaim keys (Needed for Supertab)
line 2: 
line 3: if exists("b:did_after_plugin_ultisnips_after")
line 4:    finish
line 5: endif
line 6: let b:did_after_plugin_ultisnips_after = 1
line 7: 
line 8: call UltiSnips#map_keys#MapKeys()
calling UltiSnips#map_keys#MapKeys()

line 1:     if exists("g:UltiSnipsExpandOrJumpTrigger")
line 2:         exec "inoremap <silent> " . g:UltiSnipsExpandOrJumpTrigger . " <C-R>=UltiSnips#ExpandSnippetOrJump()<cr>"
line 3:         exec "snoremap <silent> " . g:UltiSnipsExpandOrJumpTrigger . " <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>"
line 4:     elseif exists("g:UltiSnipsJumpOrExpandTrigger")
line 5:         exec "inoremap <silent> " . g:UltiSnipsJumpOrExpandTrigger . " <C-R>=UltiSnips#JumpOrExpandSnippet()<cr>"
line 6:         exec "snoremap <silent> " . g:UltiSnipsJumpOrExpandTrigger . " <Esc>:call UltiSnips#JumpOrExpandSnippet()<cr>"
line 7:     elseif g:UltiSnipsExpandTrigger == g:UltiSnipsJumpForwardTrigger
line 8:         exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippetOrJump()<cr>"
line 9:         exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>"
line 10:     else
line 11:         exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippet()<cr>"
line 11: inoremap <silent> <tab> <C-R>=UltiSnips#ExpandSnippet()<cr>
line 12:         exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippet()<cr>"
line 12: snoremap <silent> <tab> <Esc>:call UltiSnips#ExpandSnippet()<cr>
line 13:     endif
line 14:     exec "xnoremap <silent> " . g:UltiSnipsExpandTrigger. " :call UltiSnips#SaveLastVisualSelection()<cr>gvs"
line 14: xnoremap <silent> <tab> :call UltiSnips#SaveLastVisualSelection()<cr>gvs
line 15:     if len(g:UltiSnipsListSnippets) > 0
line 16:        exec "inoremap <silent> " . g:UltiSnipsListSnippets . " <C-R>=UltiSnips#ListSnippets()<cr>"
line 16: inoremap <silent> <c-tab> <C-R>=UltiSnips#ListSnippets()<cr>
line 17:        exec "snoremap <silent> " . g:UltiSnipsListSnippets . " <Esc>:call UltiSnips#ListSnippets()<cr>"
line 17: snoremap <silent> <c-tab> <Esc>:call UltiSnips#ListSnippets()<cr>
line 18:     endif
line 19: 
line 20:     snoremap <silent> <BS> <c-g>"_c
line 21:     snoremap <silent> <DEL> <c-g>"_c
line 22:     snoremap <silent> <c-h> <c-g>"_c
line 23:     snoremap <c-r> <c-g>"_c<c-r>
UltiSnips#map_keys#MapKeys returning #0

continuing in /Users/josh/.local/share/nvim/lazy/ultisnips/after/plugin/UltiSnips_after.vim

finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/after/plugin/UltiSnips_after.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
Executing User Autocommands for "LazyDone"
autocommand <Lua 102: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:183>

Executing: 
line 8: lua require('config.lsp')
line 9: " lua require('custom.goc')
line 10: 
finished sourcing /Users/josh/.config/nvim/init.vim
Reading ShaDa file "/Users/josh/.local/state/nvim/shada/main.shada" info marks oldfiles
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufAdd Autocommands for "*"
autocommand <Lua 276: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 225: ~/.local/share/nvim/lazy/windows.nvim/lua/windows/autowidth.lua:63>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 267: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1310>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 270: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 236: ~/.local/share/nvim/lazy/claude-code.nvim/lua/claude-code/file_refresh.lua:37>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufEnter Autocommands for "*"
autocommand <Lua 74: ~/.config/nvim/lua/config/vim.lua:85>

line 0: sourcing "nvim_exec2() called at BufEnter Autocommands for "*":0"
line 1: checktime
finished sourcing nvim_exec2() called at BufEnter Autocommands for "*":0
continuing in BufEnter Autocommands for "*"
Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 186: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand if expand('%') ==# '' && &previewwindow && pumvisible() && getbufvar('#', '&omnifunc') ==# 'gitlab#omnifunc#handler' |    setlocal nolist linebreak filetype=markdown | endif

Executing: if expand('%') ==# '' && &previewwindow && pumvisible() && getbufvar('#', '&omnifunc') ==# 'gitlab#omnifunc#handler' |    setlocal nolist linebreak filetype=markdown | endif
Executing:     setlocal nolist linebreak filetype=markdown | endif
Executing:  endif
Executing BufEnter Autocommands for "*"
autocommand <Lua 266: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1280>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand call v:lua.require'lualine'.refresh({'kind': 'tabpage', 'place': ['statusline'], 'trigger': 'autocmd'})

Executing: call v:lua.require'lualine'.refresh({'kind': 'tabpage', 'place': ['statusline'], 'trigger': 'autocmd'})
Executing BufEnter Autocommands for "*"
autocommand if codeium#Enabled()|call codeium#command#StartLanguageServer()|endif

Executing: if codeium#Enabled()|call codeium#command#StartLanguageServer()|endif
Searching for "autoload/codeium.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startify/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/which-key.nvim/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/claude-code.nvim/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-go/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-nio/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-ui/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startuptime/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/plenary.nvim/autoload/codeium.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium.vim"
line 0: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium.vim"
line 1: let s:hlgroup = 'CodeiumSuggestion'
line 2: let s:request_nonce = 0
line 3: let s:using_codeium_status = 0
line 4: 
line 5: if !has('nvim')
line 6:   if empty(prop_type_get(s:hlgroup))
line 7:     call prop_type_add(s:hlgroup, {'highlight': s:hlgroup})
line 8:   endif
line 9: endif
line 10: 
line 11: let s:default_codeium_enabled = { 'help': 0, 'gitcommit': 0, 'gitrebase': 0, '.': 0}
line 16: 
line 17: function! codeium#Enabled() abort
line 33: 
line 34: function! codeium#CompletionText() abort
line 41: 
line 42: function! s:CompletionInserter(current_completion, insert_text) abort
line 89: 
line 90: function! codeium#Accept() abort
line 94: 
line 95: function! codeium#AcceptNextWord() abort
line 106: 
line 107: function! codeium#AcceptNextLine() abort
line 112: 
line 113: function! s:HandleCompletionsResult(out, err, status) abort
line 140: 
line 141: function! s:GetCurrentCompletionItem() abort
line 151: 
line 152: let s:nvim_extmark_ids = []
line 153: 
line 154: function! s:ClearCompletion() abort
line 165: 
line 166: function! s:RenderCurrentCompletion() abort
line 288: 
line 289: function! codeium#Clear(...) abort
line 316: 
line 317: function! codeium#CycleCompletions(n) abort
line 333: 
line 334: function! codeium#Complete(...) abort
line 403: 
line 404: function! codeium#DebouncedComplete(...) abort
line 413: 
line 414: function! codeium#CycleOrComplete() abort
line 421: 
line 422: function BuildChatUrl(metadata, chat_port, ws_port) abort
line 433: 
line 434: function! s:LaunchChat(out, err, status) abort
line 460: 
line 461: let g:codeium_workspace_root_hints = ['.bzr','.git','.hg','.svn','_FOSSIL_','package.json']
line 462: function! s:GetProjectRoot() abort
line 477: 
line 478: function! codeium#RefreshContext() abort
line 486: 
line 487: " This assumes a single workspace is involved per Vim session, for now.
line 488: let s:codeium_workspace_indexed = v:false
line 489: function! codeium#AddTrackedWorkspace() abort
line 500: 
line 501: function! codeium#Chat() abort
line 521: 
line 522: function! codeium#GetStatusString(...) abort
line 549: 
line 550: function! codeium#RedrawStatusLine() abort
line 555: 
line 556: function! codeium#ServerLeave() abort
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium.vim
continuing in BufEnter Autocommands for "*"
calling codeium#Enabled()

line 1:   if !get(g:, 'codeium_enabled', v:true) || !get(b:, 'codeium_enabled', v:true)
line 2:     return v:false
line 3:   endif
line 4: 
line 5:   let codeium_filetypes = s:default_codeium_enabled
line 6:   call extend(codeium_filetypes, get(g:, 'codeium_filetypes', {}))
line 7: 
line 8:   let codeium_filetypes_disabled_by_default = get(g:, 'codeium_filetypes_disabled_by_default') || get(b:, 'codeium_filetypes_disabled_by_default')
line 9: 
line 10:   if !get(codeium_filetypes, &filetype, !codeium_filetypes_disabled_by_default)
line 11:     return v:false
line 12:   endif
line 13: 
line 14:   return v:true
codeium#Enabled returning v:true

continuing in BufEnter Autocommands for "*"

Executing: call codeium#command#StartLanguageServer()|endif
Searching for "autoload/codeium/command.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startify/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/which-key.nvim/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/claude-code.nvim/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-go/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-nio/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-ui/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startuptime/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/plenary.nvim/autoload/codeium/command.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/command.vim"
line 0: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/command.vim"
line 1: function! codeium#command#BrowserCommand() abort
line 12: 
line 13: function! codeium#command#XdgConfigDir() abort
line 20: 
line 21: function! codeium#command#HomeDir() abort
line 30: 
line 31: function! codeium#command#LoadConfig(dir) abort
line 42: 
line 43: let s:api_key = get(codeium#command#LoadConfig(codeium#command#HomeDir()), 'apiKey', '')
calling codeium#command#HomeDir()

line 1:   let data_dir = $XDG_DATA_HOME
line 2:   if empty(data_dir)
line 3:     let data_dir = $HOME . '/.codeium'
line 4:   else
line 5:     let data_dir = data_dir . '/.codeium'
line 6:   endif
line 7:   return data_dir
codeium#command#HomeDir returning '/Users/josh/.codeium'

continuing in /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/command.vim

calling codeium#command#LoadConfig('/Users/josh/.codeium')

line 1:   let config_path = a:dir . '/config.json'
line 2:   if filereadable(config_path)
line 3:     let contents = join(readfile(config_path), '')
line 4:     if !empty(contents)
line 5:       return json_decode(contents)
codeium#command#LoadConfig returning {'apiKey': 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'}

continuing in /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/command.vim

line 44: 
line 45: let s:commands = {}
line 46: 
line 47: function! s:commands.Auth(...) abort
line 139: 
line 140: function s:commands.Chat(...) abort
line 143: 
line 144: function! s:commands.Disable(...) abort
line 147: 
line 148: function! s:commands.DisableBuffer(...) abort
line 151: 
line 152: " Run codeium server only if its not already started
line 153: function! codeium#command#StartLanguageServer() abort
line 159: 
line 160: function! s:commands.Enable(...) abort
line 164: 
line 165: function! s:commands.EnableBuffer(...) abort
line 169: 
line 170: function! s:commands.Toggle(...) abort
line 177: 
line 178: function! codeium#command#ApiKey() abort
line 184: 
line 185: function! codeium#command#Complete(arg, lead, pos) abort
line 189: 
line 190: function! codeium#command#Command(arg) abort
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/command.vim
continuing in BufEnter Autocommands for "*"
calling codeium#command#StartLanguageServer()

line 1:   if !get(g:, 'codeium_server_started', v:false)
line 2:     call timer_start(0, function('codeium#server#Start'))
line 3:     let g:codeium_server_started = v:true
line 4:   endif
codeium#command#StartLanguageServer returning #0

continuing in BufEnter Autocommands for "*"

Executing: endif
autocommand if mode() =~# '^[iR]'|call codeium#DebouncedComplete()|endif

Executing: if mode() =~# '^[iR]'|call codeium#DebouncedComplete()|endif
Executing: call codeium#DebouncedComplete()|endif
Executing: endif
Executing BufEnter Autocommands for "*"
autocommand <Lua 107: ~/.local/share/nvim/lazy/claude-code.nvim/lua/claude-code/file_refresh.lua:37>

Executing: 
Executing: q
Executing ExitPre Autocommands for "*"
autocommand <Lua 352: ~/.local/share/nvim/lazy/nvim-dap/lua/dap.lua:1358>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 206: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 262: ~/.local/share/nvim/lazy/mason.nvim/lua/mason/init.lua:9>

Executing: 
autocommand <Lua 269: /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/lua/vim/lsp.lua:1190>

Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand call s:on_vimleavepre()

Executing: call s:on_vimleavepre()
calling <SNR>78_on_vimleavepre()

line 1:   if get(g:, 'startify_session_persistence') && exists('v:this_session') && filewritable(v:this_session)
line 4:     call startify#session_write(fnameescape(v:this_session))
line 5:   endif
<SNR>78_on_vimleavepre returning #0

continuing in VimLeavePre Autocommands for "*"

Executing VimLeavePre Autocommands for "*"
autocommand <Lua 372: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/async.lua:17>

Executing: 
Writing ShaDa file "/Users/josh/.local/state/nvim/shada/main.shada"
Executing VimLeave Autocommands for "*"
autocommand call codeium#ServerLeave()

Executing: call codeium#ServerLeave()
calling codeium#ServerLeave()

line 1:   if !exists('g:codeium_server_job') || g:codeium_server_job is v:null
line 2:     return
codeium#ServerLeave returning #0

continuing in VimLeave Autocommands for "*"

Searching for "autoload/codeium/server.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startify/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/which-key.nvim/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/claude-code.nvim/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-go/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-nio/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-ui/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startuptime/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/plenary.nvim/autoload/codeium/server.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/server.vim"
line 0: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/server.vim"
line 1: let s:language_server_version = '1.20.8'
line 2: let s:language_server_sha = '37f12b83df389802b7d4e293b3e1a986aca289c0'
line 3: let s:root = expand('<sfile>:h:h:h')
line 4: let s:bin = v:null
line 5: 
line 6: if has('nvim')
line 7:   let s:ide = 'neovim'
line 8: else
line 9:   let s:ide = 'vim'
line 10: endif
line 11: 
line 12: if !exists('s:editor_version')
line 13:   if has('nvim')
line 14:     let s:ide_version = matchstr(execute('version'), 'NVIM v\zs[^[:space:]]\+')
line 14: version

NVIM v0.11.3
Build type: Release
LuaJIT 2.1.1753364724

   system vimrc file: "$VIM/sysinit.vim"
  fall-back for $VIM: "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim"

Run :checkhealth for more info
line 15:   else
line 16:     let major = v:version / 100
line 17:     let minor = v:version % 100
line 18:     if exists('v:versionlong')
line 19:       let patch = printf('%04d', v:versionlong % 1000)
line 20:       let s:ide_version =  major . '.' . minor . '.' . patch
line 21:     else
line 22:       let s:ide_version =  major . '.' . minor
line 23:     endif
line 24:   endif
line 25: endif
line 26: 
line 27: let s:server_port = v:null
line 28: if codeium#util#IsUsingRemoteChat()
calling codeium#util#IsUsingRemoteChat()

line 1:   let chat_ports = get(g:, 'codeium_port_config', {})
line 2:   return has_key(chat_ports, 'chat_client') && !empty(chat_ports.chat_client) && has_key(chat_ports, 'web_server') && !empty(chat_ports.web_server)
codeium#util#IsUsingRemoteChat returning #0

continuing in /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/server.vim

line 29:   let s:server_port = 42100
line 30: endif
line 31: 
line 32: let g:codeium_server_job = v:null
line 33: 
line 34: function! s:DetectGlibcVersion() abort
line 83: 
line 84: function! s:CompareVersions(version1, version2) abort
line 103: 
line 104: function! s:IsGlibcVersionLessOrEqual(target_version) abort
line 112: 
line 113: function! s:OnExit(result, status, on_complete_cb) abort
line 123: 
line 124: function! s:OnClose(result, on_complete_cb) abort
line 133: 
line 134: function! s:NoopCallback(...) abort
line 136: 
line 137: function! codeium#server#RequestMetadata() abort
line 146: 
line 147: function! codeium#server#Request(type, data, ...) abort
line 185: 
line 186: function! s:FindPort(dir, timer) abort
line 199: 
line 200: function! s:RequestServerStatus() abort
line 203: 
line 204: function! s:HandleGetStatusResponse(out, err, status) abort
line 219: 
line 220: function! s:SendHeartbeat(timer) abort
line 227: 
line 228: function! codeium#server#Start(...) abort
line 316: 
line 317: function! s:UnzipAndStart(status) abort
line 354: 
line 355: function! s:ActuallyStart() abort
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/server.vim
continuing in command line
calling codeium#server#Start(1)

line 1:   let user_defined_codeium_bin = get(g:, 'codeium_bin', '')
line 2: 
line 3:   if user_defined_codeium_bin != '' && filereadable(user_defined_codeium_bin)
line 4:     let s:bin = user_defined_codeium_bin
line 5:     call s:ActuallyStart()
line 6:     return
line 7:   endif
line 8:   let user_defined_os = get(g:, 'codeium_os', '')
line 9:   let user_defined_arch = get(g:, 'codeium_arch', '')
line 10: 
line 11:   if user_defined_os != '' && user_defined_arch != ''
line 12:     let os = user_defined_os
line 13:     let arch = user_defined_arch
line 14:   else
line 15:     silent let os = substitute(system('uname'), '\n', '', '')
Executing command: "'/bin/zsh' '-c' 'uname'"


line 16:     silent let arch = substitute(system('uname -m'), '\n', '', '')
Executing command: "'/bin/zsh' '-c' 'uname -m'"


line 17:   endif
line 18:   let is_arm = stridx(arch, 'arm') == 0 || stridx(arch, 'aarch64') == 0
line 19: 
line 20:   if empty(os)
line 21:     if has("linux")
line 22:       let os = "Linux"
line 23:     elseif has("mac")
line 24:       let os = "Darwin"
line 25:     endif
line 26:   endif
line 27: 
line 28:   if os ==# 'Linux' && is_arm
line 29:     let bin_suffix = 'linux_arm'
line 30:   elseif os ==# 'Linux'
line 31:     let bin_suffix = 'linux_x64'
line 32:   elseif os ==# 'Darwin' && is_arm
line 33:     let bin_suffix = 'macos_arm'
line 34:   elseif os ==# 'Darwin'
line 35:     let bin_suffix = 'macos_x64'
line 36:   else
line 37:     let bin_suffix = 'windows_x64.exe'
line 38:   endif
line 39: 
line 40:   let config = get(g:, 'codeium_server_config', {})
line 41:   if has_key(config, 'portal_url') && !empty(config.portal_url)
line 42:     let has_old_glibc = s:IsGlibcVersionLessOrEqual('2.27')
line 43:     if has_old_glibc
line 44:       call codeium#log#Info('Using legacy language server version 1.46.0 for enterprise customer with glibc <= 2.27')
line 45:       let s:language_server_version = '1.46.0'
line 46:       let s:language_server_sha = 'enterprise-' . s:language_server_version
line 47:     else
line 48:       let response = system('curl -sL ' . config.portal_url . '/api/version')
line 49:       if v:shell_error == '0'
line 50:         let s:language_server_version = response
line 51:         let s:language_server_sha = 'enterprise-' . s:language_server_version
line 52:       else
line 53:         call codeium#log#Error('Failed to fetch version from ' . config.portal_url)
line 54:         call codeium#log#Error(v:shell_error)
line 55:       endif
line 56:     endif
line 57:   endif
line 58: 
line 59:   let sha = get(codeium#command#LoadConfig(codeium#command#XdgConfigDir()), 'sha', s:language_server_sha)
calling codeium#command#XdgConfigDir()

line 1:   let config_dir = $XDG_CONFIG_HOME
line 2:   if empty(config_dir)
line 3:     let config_dir = $HOME . '/.config'
line 4:   endif
line 5:   return config_dir . '/codeium'
codeium#command#XdgConfigDir returning '/Users/josh/.config/codeium'

continuing in codeium#server#Start

calling codeium#command#LoadConfig('/Users/josh/.config/codeium')

line 1:   let config_path = a:dir . '/config.json'
line 2:   if filereadable(config_path)
line 3:     let contents = join(readfile(config_path), '')
line 4:     if !empty(contents)
line 5:       return json_decode(contents)
line 6:     endif
line 7:   endif
line 8: 
line 9:   return {}
codeium#command#LoadConfig returning {}

continuing in codeium#server#Start

line 60:   let bin_dir = codeium#command#HomeDir() . '/bin/' . sha
calling codeium#command#HomeDir()

line 1:   let data_dir = $XDG_DATA_HOME
line 2:   if empty(data_dir)
line 3:     let data_dir = $HOME . '/.codeium'
line 4:   else
line 5:     let data_dir = data_dir . '/.codeium'
line 6:   endif
line 7:   return data_dir
codeium#command#HomeDir returning '/Users/josh/.codeium'

continuing in codeium#server#Start

line 61:   let s:bin = bin_dir . '/language_server_' . bin_suffix
line 62:   call mkdir(bin_dir, 'p')
line 63: 
line 64:   if !filereadable(s:bin)
line 65:     call delete(s:bin)
line 66:     if sha ==# s:language_server_sha
line 67:       let config = get(g:, 'codeium_server_config', {})
line 68:       if has_key(config, 'portal_url') && !empty(config.portal_url)
line 69:         let base_url = config.portal_url
line 70:       else
line 71:         let base_url = 'https://github.com/Exafunction/codeium/releases/download'
line 72:       endif
line 73:       let base_url = substitute(base_url, '/\+$', '', '')
line 74:       let url = base_url . '/language-server-v' . s:language_server_version . '/language_server_' . bin_suffix . '.gz'
line 75:     else
line 76:       let url = 'https://storage.googleapis.com/exafunction-dist/codeium/' . sha . '/language_server_' . bin_suffix . '.gz'
line 77:     endif
line 78:     let args = ['curl', '-Lo', s:bin . '.gz', url]
line 79:     if has('nvim')
line 80:       let s:download_job = jobstart(args, {'on_exit': { job, status, t -> s:UnzipAndStart(status) }})
line 81:     else
line 82:       let s:download_job = job_start(args, {'exit_cb': { job, status -> s:UnzipAndStart(status) }})
line 83:     endif
line 84:   else
line 85:     call s:ActuallyStart()
calling <SNR>111_ActuallyStart()

line 1:   let config = get(g:, 'codeium_server_config', {})
line 2:   let chat_ports = get(g:, 'codeium_port_config', {})
line 3:   let manager_dir = tempname() . '/codeium/manager'
line 4:   call mkdir(manager_dir, 'p')
line 5:   let args = [ s:bin, '--api_server_url', get(config, 'api_url', 'https://server.codeium.com'), '--enable_local_search', '--enable_index_service', '--search_max_workspace_file_count', '5000', '--enable_chat_web_server', '--enable_chat_client' ]
line 11:   if has_key(config, 'api_url') && !empty(config.api_url)
line 12:     let args += ['--enterprise_mode']
line 13:     let args += ['--portal_url', get(config, 'portal_url', 'https://codeium.example.com')]
line 14:   endif
line 15:   if !codeium#util#IsUsingRemoteChat()
calling codeium#util#IsUsingRemoteChat()

line 1:   let chat_ports = get(g:, 'codeium_port_config', {})
line 2:   return has_key(chat_ports, 'chat_client') && !empty(chat_ports.chat_client) && has_key(chat_ports, 'web_server') && !empty(chat_ports.web_server)
codeium#util#IsUsingRemoteChat returning #0

continuing in <SNR>111_ActuallyStart

line 16:     let args += ['--manager_dir', manager_dir]
line 17:   endif
line 18:   " If either of these is set, only one vim window (with any number of buffers) will work with Codeium.
line 19:   " Opening other vim windows won't be able to use Codeium features.
line 20:   if has_key(chat_ports, 'web_server') && !empty(chat_ports.web_server)
line 21:     let args += ['--chat_web_server_port', chat_ports.web_server]
line 22:   endif
line 23:   if has_key(chat_ports, 'chat_client') && !empty(chat_ports.chat_client)
line 24:     let args += ['--chat_client_port', chat_ports.chat_client]
line 25:   endif
line 26: 
line 27:   call codeium#log#Info('Launching server with manager_dir ' . manager_dir)
Searching for "autoload/codeium/log.vim" in runtime path
Searching for "/Users/josh/.config/nvim/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/site/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/lazy.nvim/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startify/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/which-key.nvim/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-buffer/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/claude-code.nvim/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-path/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-go/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-nio/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-dap-ui/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/vim-startuptime/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/plenary.nvim/autoload/codeium/log.vim"
Searching for "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/log.vim"
line 27: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/log.vim"
line 1: if exists('g:loaded_codeium_log')
line 2:   finish
line 3: endif
line 4: let g:loaded_codeium_log = 1
line 5: 
line 6: if !exists('s:logfile')
line 7:   let s:logfile = expand(get(g:, 'codeium_log_file', tempname() . '-codeium.log'))
line 8:   try
line 9:     call writefile([], s:logfile)
line 10:   catch
line 11:   endtry
line 12: endif
line 13: 
line 14: function! codeium#log#Logfile() abort
line 17: 
line 18: function! codeium#log#Log(level, msg) abort
line 35: 
line 36: function! codeium#log#Error(msg) abort
line 39: 
line 40: function! codeium#log#Warn(msg) abort
line 43: 
line 44: function! codeium#log#Info(msg) abort
line 47: 
line 48: function! codeium#log#Debug(msg) abort
line 51: 
line 52: function! codeium#log#Trace(msg) abort
line 55: 
line 56: function! codeium#log#Exception() abort
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/log.vim
continuing in <SNR>111_ActuallyStart
calling codeium#log#Info('Launching server with manager_dir /va...n/T/nvim.josh/C9rqgs/0/codeium/manager')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', 'Launching server with manager_dir /va...n/T/nvim.josh/C9rqgs/0/codeium/manager')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <SNR>111_ActuallyStart

line 28:   if has('nvim')
line 29:     let g:codeium_server_job = jobstart(args, { 'on_stderr': { channel, data, t -> codeium#log#Info('[SERVER] ' . join(data, "\n")) }, })
line 32:   else
line 33:     let g:codeium_server_job = job_start(args, { 'out_mode': 'raw', 'err_cb': { channel, data -> codeium#log#Info('[SERVER] ' . data) }, })
line 37:   endif
line 38:   if !codeium#util#IsUsingRemoteChat()
calling codeium#util#IsUsingRemoteChat()

line 1:   let chat_ports = get(g:, 'codeium_port_config', {})
line 2:   return has_key(chat_ports, 'chat_client') && !empty(chat_ports.chat_client) && has_key(chat_ports, 'web_server') && !empty(chat_ports.web_server)
codeium#util#IsUsingRemoteChat returning #0

continuing in <SNR>111_ActuallyStart

line 39:     call timer_start(500, function('s:FindPort', [manager_dir]), {'repeat': -1})
line 40:   endif
line 41: 
line 42:   call timer_start(5000, function('s:SendHeartbeat', []), {'repeat': -1})
<SNR>111_ActuallyStart returning #0

continuing in codeium#server#Start

line 86:   endif
codeium#server#Start returning #0

continuing in command line

calling <lambda>1(4, ['2025/08/06 12:59:51 maxprocs: Leaving GOMAXPROCS=14: CPU quota undefined', ''], 'stderr')

calling codeium#log#Info('[SERVER] 2025/08/06 12:59:51 maxprocs...g GOMAXPROCS=14: CPU quota undefined
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] 2025/08/06 12:59:51 maxprocs...g GOMAXPROCS=14: CPU quota undefined
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.184304 51134 main.go:...Manager] Setting GOMAXPROCS to 14', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.184304 51134 ...er Manager] Setting GOMAXPROCS to 14
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.184304 51134 ...er Manager] Setting GOMAXPROCS to 14
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.186852 51134 main.go:...age server manager with pid 51134', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.186852 51134 ...nguage server manager with pid 51134
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.186852 51134 ...nguage server manager with pid 51134
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.188064 51134 main.go:...odeium/manager/locks/manager.lock', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.188064 51134 ...0/codeium/manager/locks/manager.lock
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.188064 51134 ...0/codeium/manager/locks/manager.lock
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.191038 51134 main.go:...7000202623477823494 to be created', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.191038 51134 ...00_7000202623477823494 to be created
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.191038 51134 ...00_7000202623477823494 to be created
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['2025/08/06 12:59:51 maxprocs: Leaving GOMAXPROCS=14: CPU quota undefined', ''], 'stderr')

calling codeium#log#Info('[SERVER] 2025/08/06 12:59:51 maxprocs...g GOMAXPROCS=14: CPU quota undefined
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] 2025/08/06 12:59:51 maxprocs...g GOMAXPROCS=14: CPU quota undefined
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.234315 51135 main.go:552] Setting GOMAXPROCS to 4', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.234315 51135 main.go:552] Setting GOMAXPROCS to 4
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.234315 51135 main.go:552] Setting GOMAXPROCS to 4
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.235789 51135 main.go:...age server process with pid 51135', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.235789 51135 ...nguage server process with pid 51135
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.235789 51135 ...nguage server process with pid 51135
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.235829 51135 server.g...listening on random port at 61233', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.235829 51135 ...er listening on random port at 61233
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.235829 51135 ...er listening on random port at 61233
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['2025/08/06 12:59:51 [proxy.Provider....: Automatic proxy is not enabled.', ''], 'stderr')

calling codeium#log#Info('[SERVER] 2025/08/06 12:59:51 [proxy.P...xy]: Automatic proxy is not enabled.
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] 2025/08/06 12:59:51 [proxy.P...xy]: Automatic proxy is not enabled.
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['2025/08/06 12:59:51 [proxy.Provider....oxy]: https proxy is not enabled.', ''], 'stderr')

calling codeium#log#Info('[SERVER] 2025/08/06 12:59:51 [proxy.P...gProxy]: https proxy is not enabled.
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] 2025/08/06 12:59:51 [proxy.P...gProxy]: https proxy is not enabled.
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.385285 51135 unleash.go:93] Initializing Unleash', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.385285 51135 unleash.go:93] Initializing Unleash
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.385285 51135 unleash.go:93] Initializing Unleash
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.511393 51135 unleash.... Successfully initialized Unleash', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.511393 51135 ...13] Successfully initialized Unleash
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.511393 51135 ...13] Successfully initialized Unleash
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['E0806 12:59:51.545746 51135 client_m...l when trying to refresh user JWT', ''], 'stderr')

calling codeium#log#Info('[SERVER] E0806 12:59:51.545746 51135 ... nil when trying to refresh user JWT
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] E0806 12:59:51.545746 51135 ... nil when trying to refresh user JWT
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.545959 51135 server.g...ssfully created API server client', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.545959 51135 ...ccessfully created API server client
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.545959 51135 ...ccessfully created API server client
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.559788 51135 server.g...uccessfully initialized tokenizer', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.559788 51135 ...] Successfully initialized tokenizer
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.559788 51135 ...] Successfully initialized tokenizer
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.560463 51135 server.g... enabled, will index local files.', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.560463 51135 ... is enabled, will index local files.
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.560463 51135 ... is enabled, will index local files.
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.560472 51135 server.go:582] Using 3 indexer workers', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.560472 51135 server.go:582] Using 3 indexer workers
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.560472 51135 server.go:582] Using 3 indexer workers
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.561714 51135 sqlite_f... embedding search database in 1ms', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.561714 51135 ...ted embedding search database in 1ms
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.561714 51135 ...ted embedding search database in 1ms
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.561843 51135 indexer.go:213] Using 4 embed workers', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.561843 51135 indexer.go:213] Using 4 embed workers
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.561843 51135 indexer.go:213] Using 4 embed workers
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.561870 51135 search_p...created embedding search provider', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.561870 51135 ...ly created embedding search provider
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.561870 51135 ...ly created embedding search provider
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <SNR>111_FindPort('/var/folders/qq/wj1zqpp53hb6fbs37r7mh...n/T/nvim.josh/C9rqgs/0/codeium/manager', 2)

line 1:   let time = localtime()
line 2:   for name in readdir(a:dir)
line 3:     let path = a:dir . '/' . name
line 4:     if time - getftime(path) <= 5 && getftype(path) ==# 'file'
line 5:       call codeium#log#Info('Found port: ' . name)
line 6:       let s:server_port = name
line 7:       call s:RequestServerStatus()
line 8:       call timer_stop(a:timer)
line 9:       break
line 10:     endif
line 11:   endfor
line 2:   for name in readdir(a:dir)
line 3:     let path = a:dir . '/' . name
line 4:     if time - getftime(path) <= 5 && getftype(path) ==# 'file'
line 5:       call codeium#log#Info('Found port: ' . name)
line 6:       let s:server_port = name
line 7:       call s:RequestServerStatus()
line 8:       call timer_stop(a:timer)
line 9:       break
line 10:     endif
line 11:   endfor
line 2:   for name in readdir(a:dir)
line 3:     let path = a:dir . '/' . name
line 4:     if time - getftime(path) <= 5 && getftype(path) ==# 'file'
line 5:       call codeium#log#Info('Found port: ' . name)
line 6:       let s:server_port = name
line 7:       call s:RequestServerStatus()
line 8:       call timer_stop(a:timer)
line 9:       break
line 10:     endif
line 11:   endfor
line 2:   for name in readdir(a:dir)
line 3:     let path = a:dir . '/' . name
line 4:     if time - getftime(path) <= 5 && getftype(path) ==# 'file'
line 5:       call codeium#log#Info('Found port: ' . name)
line 6:       let s:server_port = name
line 7:       call s:RequestServerStatus()
line 8:       call timer_stop(a:timer)
line 9:       break
line 10:     endif
line 11:   endfor
<SNR>111_FindPort returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.805730 51135 server.g...fully created completion provider', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.805730 51135 ...essfully created completion provider
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.805730 51135 ...essfully created completion provider
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.805747 51135 server.g...9591188707000_1416485542010783636', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.805747 51135 ...4499591188707000_1416485542010783636
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.805747 51135 ...4499591188707000_1416485542010783636
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.808452 51135 web_serv...tening at https://127.0.0.1:61240', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.808452 51135 ...listening at https://127.0.0.1:61240
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.808452 51135 ...listening at https://127.0.0.1:61240
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.808677 51135 web_serv...listening at ws://127.0.0.1:61239', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.808677 51135 ...er listening at ws://127.0.0.1:61239
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.808677 51135 ...er listening at ws://127.0.0.1:61239
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.897752 51134 main.go:...r] Found random server port 61233', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.897752 51134 ...ager] Found random server port 61233
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.897752 51134 ...ager] Found random server port 61233
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.897804 51134 main.go:...anguage server at 127.0.0.1:61233', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.897804 51134 ...o language server at 127.0.0.1:61233
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.897804 51134 ...o language server at 127.0.0.1:61233
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.913490 51134 main.go:...ing language server port at 61233', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.913490 51134 ...Fixing language server port at 61233
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.913490 51134 ...Fixing language server port at 61233
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <lambda>1(4, ['I0806 12:59:51.913498 51134 main.go:...anguage server at 127.0.0.1:61233', ''], 'stderr')

calling codeium#log#Info('[SERVER] I0806 12:59:51.913498 51134 ...w language server at 127.0.0.1:61233
')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', '[SERVER] I0806 12:59:51.913498 51134 ...w language server at 127.0.0.1:61233
')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <lambda>1

<lambda>1 returning #0

continuing in command line

calling <SNR>111_FindPort('/var/folders/qq/wj1zqpp53hb6fbs37r7mh...n/T/nvim.josh/C9rqgs/0/codeium/manager', 2)

line 1:   let time = localtime()
line 2:   for name in readdir(a:dir)
line 3:     let path = a:dir . '/' . name
line 4:     if time - getftime(path) <= 5 && getftype(path) ==# 'file'
line 5:       call codeium#log#Info('Found port: ' . name)
calling codeium#log#Info('Found port: 61233')

line 1:   call codeium#log#Log('INFO', a:msg)
calling codeium#log#Log('INFO', 'Found port: 61233')

line 1:   let min_level = toupper(get(g:, 'codeium_log_level', 'WARN'))
line 2:   " echo "logging to: " . s:logfile . "," . min_level . "," . a:level . "," a:msg
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
line 3:   for level in ['ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE']
line 4:     if level == toupper(a:level)
line 5:       try
line 6:         if filewritable(s:logfile)
line 7:           call writefile(split(a:msg, "\n", 1), s:logfile, 'a')
line 8:         endif
line 9:       catch
line 10:       endtry
line 11:     endif
line 12:     if level == min_level
line 13:       break
line 14:     endif
line 15:   endfor
codeium#log#Log returning #0

continuing in codeium#log#Info

codeium#log#Info returning #0

continuing in <SNR>111_FindPort

line 6:       let s:server_port = name
line 7:       call s:RequestServerStatus()
calling <SNR>111_RequestServerStatus()

line 1:   call codeium#server#Request('GetStatus', {'metadata': codeium#server#RequestMetadata()}, function('s:HandleGetStatusResponse'))
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_RequestServerStatus

calling codeium#server#Request('GetStatus', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}}, function('<SNR>111_HandleGetStatusResponse'))

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #5

continuing in <SNR>111_RequestServerStatus

<SNR>111_RequestServerStatus returning #0

continuing in <SNR>111_FindPort

line 8:       call timer_stop(a:timer)
line 9:       break
line 10:     endif
line 11:   endfor
<SNR>111_FindPort returning #0

continuing in command line

calling <lambda>3(5, ['  % Total    % Rece'], 'stderr')

<lambda>3 returning ['  % Total    % Rece']

continuing in command line

calling <lambda>3(5, ['ived % Xferd  Average Speed   Time  ...     Time  Current', '               '], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ...me     Time  Current^@               ']

continuing in command line

calling <lambda>3(5, ['                  Dload  Upload   Total   '], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ...             Dload  Upload   Total   ']

continuing in command line

calling <lambda>3(5, ['Spent    Left  Speed', '  0   '], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ...   ', 'Spent    Left  Speed^@^M  0   ']

continuing in command line

calling <lambda>3(5, ['  0    0     0    0     0    '], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ...0   ', '  0    0     0    0     0    ']

continuing in command line

calling <lambda>3(5, ['  0      0 --:--:-- --:'], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ...     0    ', '  0      0 --:--:-- --:']

continuing in command line

calling <lambda>3(5, ['--:-- --:--:--     0'], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ... --:--:-- --:', '--:-- --:--:--     0']

continuing in command line

calling <lambda>3(5, ['100   181 '], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ...'--:-- --:--:--     0', '^M100   181 ']

continuing in command line

calling <lambda>3(5, [' 100    13  100   168    159   2064 --:--:-- --:--:-- --:--:--  2234'], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ...2064 --:--:-- --:--:-- --:--:--  2234']

continuing in command line

calling <lambda>2(5, ['{"status":{}}'], 'stdout')

<lambda>2 returning ['{"status":{}}']

continuing in command line

calling <lambda>3(5, ['', ''], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ...-:--:-- --:--:-- --:--:--  2234', '^@']

continuing in command line

calling <lambda>2(5, [''], 'stdout')

<lambda>2 returning ['{"status":{}}', '']

continuing in command line

calling <lambda>3(5, [''], 'stderr')

<lambda>3 returning ['  % Total    % Rece', 'ived % Xferd ...:-- --:--:-- --:--:--  2234', '^@', '']

continuing in command line

calling <lambda>4(5, 0, 'exit')

calling <SNR>111_HandleGetStatusResponse(['{"status":{}}', ''], ['  % Total    % Rece', 'ived % Xferd ...:-- --:--:-- --:--:--  2234', '
', ''], 0)

line 1:   " Check if the request was successful
line 2:   if a:status == 0
line 3:     " Parse the JSON response
line 4:     let response = json_decode(join(a:out, "\n"))
line 5:     let status = get(response, 'status', {})
line 6:     " Check if there is a message in the response and echo it
line 7:     if has_key(status, 'message') && !empty(status.message)
line 8:       echom status.message
line 9:     endif
line 10:   else
line 11:     " Handle error if the status is not 0 or if there is stderr output
line 12:     call codeium#log#Error(join(a:err, "\n"))
line 13:   endif
<SNR>111_HandleGetStatusResponse returning #0

continuing in <lambda>4

<lambda>4 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #6

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>6(6, ['  % Total '], 'stderr')

<lambda>6 returning ['  % Total ']

continuing in command line

calling <lambda>6(6, ['   % Received % Xferd  Average Speed...  Time  Current', '                  '], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ...    Time  Current^@                  ']

continuing in command line

calling <lambda>6(6, ['               Dload  Upload   Total   Spen'], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ...         Dload  Upload   Total   Spen']

continuing in command line

calling <lambda>6(6, ['t    Left  Speed', '  0     0 '], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ...pen', 't    Left  Speed^@^M  0     0 ']

continuing in command line

calling <lambda>6(6, ['   0     0    0     0      0      0'], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ... '   0     0    0     0      0      0']

continuing in command line

calling <lambda>6(6, [' --:--:-- --:--:-- --:--:--   '], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ...  0', ' --:--:-- --:--:-- --:--:--   ']

continuing in command line

calling <lambda>6(6, ['  0'], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ... --:--:-- --:--:-- --:--:--   ', '  0']

continuing in command line

calling <lambda>6(6, ['100  '], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ...-:--:-- --:--:--   ', '  0', '^M100  ']

continuing in command line

calling <lambda>6(6, [' 224  100    56  100   168  93178   272k -'], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ... 100    56  100   168  93178   272k -']

continuing in command line

calling <lambda>6(6, ['-:--:-- --:--:-- --:--:--  218k', ''], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ...', '-:--:-- --:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>5(6, ['{"lastExtensionHeartbeat":"2025-08-06T16:59:56.100567Z"}'], 'stdout')

<lambda>5 returning ['{"lastExtensionHeartbeat":"2025-08-06T16:59:56.100567Z"}']

continuing in command line

calling <lambda>6(6, [''], 'stderr')

<lambda>6 returning ['  % Total ', '   % Received % Xferd ...-:--:-- --:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>5(6, [''], 'stdout')

<lambda>5 returning ['{"lastExtensionHeartbeat":"2025-08-06T16:59:56.100567Z"}', '']

continuing in command line

calling <lambda>7(6, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T16:59:56.100567Z"}', ''], ['  % Total ', '   % Received % Xferd ...-:--:-- --:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>7

<lambda>7 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #7

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>9(7, ['  % Total    % Rec'], 'stderr')

<lambda>9 returning ['  % Total    % Rec']

continuing in command line

calling <lambda>9(7, ['eived % Xferd  Average Speed   Time ...'                                 Dlo'], 'stderr')

<lambda>9 returning ['  % Total    % Rec', 'eived % Xferd ...                                 Dlo']

continuing in command line

calling <lambda>9(7, ['ad  Upload   Total   Spent    Left  Spe'], 'stderr')

<lambda>9 returning ['  % Total    % Rec', 'eived % Xferd ...  Upload   Total   Spent    Left  Spe']

continuing in command line

calling <lambda>9(7, ['ed', '  0     0    0     0    '], 'stderr')

<lambda>9 returning ['  % Total    % Rec', 'eived % Xferd ...Spe', 'ed^@^M  0     0    0     0    ']

continuing in command line

calling <lambda>9(7, ['0     0      0      0 --:--:--'], 'stderr')

<lambda>9 returning ['  % Total    % Rec', 'eived % Xferd ...   ', '0     0      0      0 --:--:--']

continuing in command line

calling <lambda>9(7, [' --:--:-- --:--:--     0'], 'stderr')

<lambda>9 returning ['  % Total    % Rec', 'eived % Xferd ... --:--:--', ' --:--:-- --:--:--     0']

continuing in command line

calling <lambda>9(7, ['100 '], 'stderr')

<lambda>9 returning ['  % Total    % Rec', 'eived % Xferd ..., ' --:--:-- --:--:--     0', '^M100 ']

continuing in command line

calling <lambda>9(7, ['  224  100    56  100   168  74966   219k --:--:-- --:--:'], 'stderr')

<lambda>9 returning ['  % Total    % Rec', 'eived % Xferd ...0   168  74966   219k --:--:-- --:--:']

continuing in command line

calling <lambda>8(7, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:01.124818Z"}'], 'stdout')

<lambda>8 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:01.124818Z"}']

continuing in command line

calling <lambda>9(7, ['-- --:--:--  218k', ''], 'stderr')

<lambda>9 returning ['  % Total    % Rec', 'eived % Xferd ...-:--:-- --:--:', '-- --:--:--  218k^@']

continuing in command line

calling <lambda>9(7, [''], 'stderr')

<lambda>9 returning ['  % Total    % Rec', 'eived % Xferd ...:-- --:--:', '-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>8(7, [''], 'stdout')

<lambda>8 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:01.124818Z"}', '']

continuing in command line

calling <lambda>10(7, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:01.124818Z"}', ''], ['  % Total    % Rec', 'eived % Xferd ...:-- --:--:', '-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>10

<lambda>10 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #8

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>12(8, ['  % Total    % Received'], 'stderr')

<lambda>12 returning ['  % Total    % Received']

continuing in command line

calling <lambda>12(8, [' % Xferd  Average Speed   Time    Ti...          Dload  Upload   Total   Spe'], 'stderr')

<lambda>12 returning ['  % Total    % Received', ' % Xferd ...          Dload  Upload   Total   Spe']

continuing in command line

calling <lambda>12(8, ['nt    Left  Speed', '  0     0    0     0    0     0    '], 'stderr')

<lambda>12 returning ['  % Total    % Received', ' % Xferd ...^M  0     0    0     0    0     0    ']

continuing in command line

calling <lambda>12(8, ['  0      0 --:--:-- --:--:-- --:--:--'], 'stderr')

<lambda>12 returning ['  % Total    % Received', ' % Xferd ...  0      0 --:--:-- --:--:-- --:--:--']

continuing in command line

calling <lambda>12(8, ['     0'], 'stderr')

<lambda>12 returning ['  % Total    % Received', ' % Xferd ... --:--:-- --:--:-- --:--:--', '     0']

continuing in command line

calling <lambda>12(8, ['100'], 'stderr')

<lambda>12 returning ['  % Total    % Received', ' % Xferd ... --:--:-- --:--:--', '     0', '^M100']

continuing in command line

calling <lambda>12(8, ['   224  100    56  100   168  78762 '], 'stderr')

<lambda>12 returning ['  % Total    % Received', ' % Xferd ...'   224  100    56  100   168  78762 ']

continuing in command line

calling <lambda>11(8, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:06.101340Z"}'], 'stdout')

<lambda>11 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:06.101340Z"}']

continuing in command line

calling <lambda>12(8, ['  230k --:--:-- --:--:-- --:--:--  218k', ''], 'stderr')

<lambda>12 returning ['  % Total    % Received', ' % Xferd ...0k --:--:-- --:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>12(8, [''], 'stderr')

<lambda>12 returning ['  % Total    % Received', ' % Xferd ...-:--:-- --:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>11(8, [''], 'stdout')

<lambda>11 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:06.101340Z"}', '']

continuing in command line

calling <lambda>13(8, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:06.101340Z"}', ''], ['  % Total    % Received', ' % Xferd ...-:--:-- --:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>13

<lambda>13 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #9

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>15(9, ['  % Total'], 'stderr')

<lambda>15 returning ['  % Total']

continuing in command line

calling <lambda>15(9, ['    % Received % Xferd  Average Spee...                                 Dloa'], 'stderr')

<lambda>15 returning ['  % Total', '    % Received % Xferd ...                                 Dloa']

continuing in command line

calling <lambda>15(9, ['d  Upload   Total   Spent    Left  Speed', '  0     0    0  '], 'stderr')

<lambda>15 returning ['  % Total', '    % Received % Xferd ...nt    Left  Speed^@^M  0     0    0  ']

continuing in command line

calling <lambda>15(9, ['   0    0     0      0      0 --:-'], 'stderr')

<lambda>15 returning ['  % Total', '    % Received % Xferd ..., '   0    0     0      0      0 --:-']

continuing in command line

calling <lambda>15(9, ['-:-- --:--:-- --:--:--     0'], 'stderr')

<lambda>15 returning ['  % Total', '    % Received % Xferd ... --:-', '-:-- --:--:-- --:--:--     0']

continuing in command line

calling <lambda>15(9, ['100 '], 'stderr')

<lambda>15 returning ['  % Total', '    % Received % Xferd ...:-- --:--:-- --:--:--     0', '^M100 ']

continuing in command line

calling <lambda>15(9, ['  224  100    56  100   168  94117   275k --:--:-- --:--:-- -'], 'stderr')

<lambda>15 returning ['  % Total', '    % Received % Xferd ...168  94117   275k --:--:-- --:--:-- -']

continuing in command line

calling <lambda>14(9, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:11.101417Z"}'], 'stdout')

<lambda>14 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:11.101417Z"}']

continuing in command line

calling <lambda>15(9, ['-:--:--  218k', ''], 'stderr')

<lambda>15 returning ['  % Total', '    % Received % Xferd ...-:--:-- --:--:-- -', '-:--:--  218k^@']

continuing in command line

calling <lambda>15(9, [''], 'stderr')

<lambda>15 returning ['  % Total', '    % Received % Xferd ...:-- --:--:-- -', '-:--:--  218k^@', '']

continuing in command line

calling <lambda>14(9, [''], 'stdout')

<lambda>14 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:11.101417Z"}', '']

continuing in command line

calling <lambda>16(9, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:11.101417Z"}', ''], ['  % Total', '    % Received % Xferd ...:-- --:--:-- -', '-:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>16

<lambda>16 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #10

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>18(10, ['  % Total    % Rece'], 'stderr')

<lambda>18 returning ['  % Total    % Rece']

continuing in command line

calling <lambda>18(10, ['ived % Xferd  Average Speed   Time  ...                            Dload  Up'], 'stderr')

<lambda>18 returning ['  % Total    % Rece', 'ived % Xferd ...                            Dload  Up']

continuing in command line

calling <lambda>18(10, ['load   Total   Spent    Left  Speed'...   0 --:--:-- --:--:-- --:--:--     0'], 'stderr')

<lambda>18 returning ['  % Total    % Rece', 'ived % Xferd ...   0 --:--:-- --:--:-- --:--:--     0']

continuing in command line

calling <lambda>18(10, ['100'], 'stderr')

<lambda>18 returning ['  % Total    % Rece', 'ived % Xferd ...-:-- --:--:-- --:--:--     0', '^M100']

continuing in command line

calling <lambda>18(10, ['   224  100    56  100   168  '], 'stderr')

<lambda>18 returning ['  % Total    % Rece', 'ived % Xferd ...100', '   224  100    56  100   168  ']

continuing in command line

calling <lambda>18(10, ['91056   266k --:--:-- --:--:-- '], 'stderr')

<lambda>18 returning ['  % Total    % Rece', 'ived % Xferd ...  ', '91056   266k --:--:-- --:--:-- ']

continuing in command line

calling <lambda>17(10, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:16.103447Z"}'], 'stdout')

<lambda>17 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:16.103447Z"}']

continuing in command line

calling <lambda>18(10, ['--:--:--  218k', ''], 'stderr')

<lambda>18 returning ['  % Total    % Rece', 'ived % Xferd ...-:--:-- --:--:-- ', '--:--:--  218k^@']

continuing in command line

calling <lambda>18(10, [''], 'stderr')

<lambda>18 returning ['  % Total    % Rece', 'ived % Xferd ...:-- --:--:-- ', '--:--:--  218k^@', '']

continuing in command line

calling <lambda>17(10, [''], 'stdout')

<lambda>17 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:16.103447Z"}', '']

continuing in command line

calling <lambda>19(10, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:16.103447Z"}', ''], ['  % Total    % Rece', 'ived % Xferd ...:-- --:--:-- ', '--:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>19

<lambda>19 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #11

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>21(11, ['  % Total    % '], 'stderr')

<lambda>21 returning ['  % Total    % ']

continuing in command line

calling <lambda>21(11, ['Received % Xferd  Average Speed   Ti...peed', '  0     0    0     0    0  '], 'stderr')

<lambda>21 returning ['  % Total    % ', 'Received % Xferd ... Speed^@^M  0     0    0     0    0  ']

continuing in command line

calling <lambda>21(11, ['   0      0      0 --:--:-- --:--:-- --:--:--     0'], 'stderr')

<lambda>21 returning ['  % Total    % ', 'Received % Xferd ...   0 --:--:-- --:--:-- --:--:--     0']

continuing in command line

calling <lambda>21(11, ['100 '], 'stderr')

<lambda>21 returning ['  % Total    % ', 'Received % Xferd ...:-- --:--:-- --:--:--     0', '^M100 ']

continuing in command line

calling <lambda>21(11, ['  224  100    56  100   168  98765   2'], 'stderr')

<lambda>21 returning ['  % Total    % ', 'Received % Xferd ... 224  100    56  100   168  98765   2']

continuing in command line

calling <lambda>21(11, ['89k --:--:-- --:--:-- --:--:--  21'], 'stderr')

<lambda>21 returning ['  % Total    % ', 'Received % Xferd ..., '89k --:--:-- --:--:-- --:--:--  21']

continuing in command line

calling <lambda>21(11, ['8k', ''], 'stderr')

<lambda>21 returning ['  % Total    % ', 'Received % Xferd ...-:--:-- --:--:-- --:--:--  21', '8k^@']

continuing in command line

calling <lambda>20(11, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:21.103474Z"}'], 'stdout')

<lambda>20 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:21.103474Z"}']

continuing in command line

calling <lambda>21(11, [''], 'stderr')

<lambda>21 returning ['  % Total    % ', 'Received % Xferd ...:-- --:--:-- --:--:--  21', '8k^@', '']

continuing in command line

calling <lambda>20(11, [''], 'stdout')

<lambda>20 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:21.103474Z"}', '']

continuing in command line

calling <lambda>22(11, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:21.103474Z"}', ''], ['  % Total    % ', 'Received % Xferd ...:-- --:--:-- --:--:--  21', '8k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>22

<lambda>22 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #12

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>24(12, ['  % Total'], 'stderr')

<lambda>24 returning ['  % Total']

continuing in command line

calling <lambda>24(12, ['    % Received % Xferd  Average Spee...                      Dload  Upload  '], 'stderr')

<lambda>24 returning ['  % Total', '    % Received % Xferd ...                      Dload  Upload  ']

continuing in command line

calling <lambda>24(12, [' Total   Spent    Left  Speed', '  0     0    0     0    0   '], 'stderr')

<lambda>24 returning ['  % Total', '    % Received % Xferd ...Speed^@^M  0     0    0     0    0   ']

continuing in command line

calling <lambda>24(12, ['  0      0      0 --:--:-- --:--:--'], 'stderr')

<lambda>24 returning ['  % Total', '    % Received % Xferd ... '  0      0      0 --:--:-- --:--:--']

continuing in command line

calling <lambda>24(12, [' --:--:--     0'], 'stderr')

<lambda>24 returning ['  % Total', '    % Received % Xferd ... --:--:-- --:--:--', ' --:--:--     0']

continuing in command line

calling <lambda>24(12, ['100 '], 'stderr')

<lambda>24 returning ['  % Total', '    % Received % Xferd ...--:--:--', ' --:--:--     0', '^M100 ']

continuing in command line

calling <lambda>24(12, ['  224  100    56  100   168  93178   272k --:--:-- --:--:'], 'stderr')

<lambda>24 returning ['  % Total', '    % Received % Xferd ...0   168  93178   272k --:--:-- --:--:']

continuing in command line

calling <lambda>23(12, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:26.104476Z"}'], 'stdout')

<lambda>23 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:26.104476Z"}']

continuing in command line

calling <lambda>24(12, ['-- --:--:--  218k', ''], 'stderr')

<lambda>24 returning ['  % Total', '    % Received % Xferd ...-:--:-- --:--:', '-- --:--:--  218k^@']

continuing in command line

calling <lambda>24(12, [''], 'stderr')

<lambda>24 returning ['  % Total', '    % Received % Xferd ...:-- --:--:', '-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>23(12, [''], 'stdout')

<lambda>23 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:26.104476Z"}', '']

continuing in command line

calling <lambda>25(12, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:26.104476Z"}', ''], ['  % Total', '    % Received % Xferd ...:-- --:--:', '-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>25

<lambda>25 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #13

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>27(13, ['  % Total    % Rece'], 'stderr')

<lambda>27 returning ['  % Total    % Rece']

continuing in command line

calling <lambda>27(13, ['ived % Xferd  Average Speed   Time  ...                    Dload  Upload   T'], 'stderr')

<lambda>27 returning ['  % Total    % Rece', 'ived % Xferd ...                    Dload  Upload   T']

continuing in command line

calling <lambda>27(13, ['otal   Spent    Left  Speed', '  0     0    0     0    0  '], 'stderr')

<lambda>27 returning ['  % Total    % Rece', 'ived % Xferd ... Speed^@^M  0     0    0     0    0  ']

continuing in command line

calling <lambda>27(13, ['   0      0      0 --:--:-- --:--:'], 'stderr')

<lambda>27 returning ['  % Total    % Rece', 'ived % Xferd ..., '   0      0      0 --:--:-- --:--:']

continuing in command line

calling <lambda>27(13, ['-- --:--:--     0'], 'stderr')

<lambda>27 returning ['  % Total    % Rece', 'ived % Xferd ... --:--:-- --:--:', '-- --:--:--     0']

continuing in command line

calling <lambda>27(13, ['100 '], 'stderr')

<lambda>27 returning ['  % Total    % Rece', 'ived % Xferd ...--:--:', '-- --:--:--     0', '^M100 ']

continuing in command line

calling <lambda>27(13, ['  224  100    56  100   168   111k'], 'stderr')

<lambda>27 returning ['  % Total    % Rece', 'ived % Xferd ..., '  224  100    56  100   168   111k']

continuing in command line

calling <lambda>27(13, ['   334k --:--:-'], 'stderr')

<lambda>27 returning ['  % Total    % Rece', 'ived % Xferd ...  100   168   111k', '   334k --:--:-']

continuing in command line

calling <lambda>27(13, ['- --:--:-- --:--:--  218k', ''], 'stderr')

<lambda>27 returning ['  % Total    % Rece', 'ived % Xferd ...-:--:-', '- --:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>26(13, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:31.106620Z"}'], 'stdout')

<lambda>26 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:31.106620Z"}']

continuing in command line

calling <lambda>27(13, [''], 'stderr')

<lambda>27 returning ['  % Total    % Rece', 'ived % Xferd ...:-', '- --:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>26(13, [''], 'stdout')

<lambda>26 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:31.106620Z"}', '']

continuing in command line

calling <lambda>28(13, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:31.106620Z"}', ''], ['  % Total    % Rece', 'ived % Xferd ...:-', '- --:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>28

<lambda>28 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #14

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>30(14, ['  % Total    % R'], 'stderr')

<lambda>30 returning ['  % Total    % R']

continuing in command line

calling <lambda>30(14, ['eceived % Xferd  Average Speed   Tim...  Time  Current', '                  '], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ...    Time  Current^@                  ']

continuing in command line

calling <lambda>30(14, ['               Dload  Upload   Total   Spent    Left'], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ...Dload  Upload   Total   Spent    Left']

continuing in command line

calling <lambda>30(14, ['  Speed', '  0     0 '], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ...pent    Left', '  Speed^@^M  0     0 ']

continuing in command line

calling <lambda>30(14, ['   0     0    0     0      0  '], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ... 0 ', '   0     0    0     0      0  ']

continuing in command line

calling <lambda>30(14, ['    0 --:--:-- --:--:-- --:--:'], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ...0  ', '    0 --:--:-- --:--:-- --:--:']

continuing in command line

calling <lambda>30(14, ['--     0'], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ... --:--:-- --:--:-- --:--:', '--     0']

continuing in command line

calling <lambda>30(14, ['100  '], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ...-:--:-- --:--:', '--     0', '^M100  ']

continuing in command line

calling <lambda>30(14, [' 224  100    56  100   168   107k   '], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ...' 224  100    56  100   168   107k   ']

continuing in command line

calling <lambda>30(14, ['321k --:--:-- --:--:-- --:--:--'], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ...  ', '321k --:--:-- --:--:-- --:--:--']

continuing in command line

calling <lambda>29(14, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:36.103351Z"}'], 'stdout')

<lambda>29 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:36.103351Z"}']

continuing in command line

calling <lambda>30(14, ['  218k', ''], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ...-:--:-- --:--:-- --:--:--', '  218k^@']

continuing in command line

calling <lambda>29(14, [''], 'stdout')

<lambda>29 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:36.103351Z"}', '']

continuing in command line

calling <lambda>30(14, [''], 'stderr')

<lambda>30 returning ['  % Total    % R', 'eceived % Xferd ...:-- --:--:-- --:--:--', '  218k^@', '']

continuing in command line

calling <lambda>31(14, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:36.103351Z"}', ''], ['  % Total    % R', 'eceived % Xferd ...:-- --:--:-- --:--:--', '  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>31

<lambda>31 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #15

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>33(15, ['  % Total '], 'stderr')

<lambda>33 returning ['  % Total ']

continuing in command line

calling <lambda>33(15, ['   % Received % Xferd  Average Speed...                               Dload '], 'stderr')

<lambda>33 returning ['  % Total ', '   % Received % Xferd ...                               Dload ']

continuing in command line

calling <lambda>33(15, [' Upload   Total   Spent    Left  Speed', '  0     0    0     0    0    '], 'stderr')

<lambda>33 returning ['  % Total ', '   % Received % Xferd ...peed^@^M  0     0    0     0    0    ']

continuing in command line

calling <lambda>33(15, [' 0      0      0 --:--:-- --:--:-- --:'], 'stderr')

<lambda>33 returning ['  % Total ', '   % Received % Xferd ...0      0      0 --:--:-- --:--:-- --:']

continuing in command line

calling <lambda>33(15, ['--:--     0'], 'stderr')

<lambda>33 returning ['  % Total ', '   % Received % Xferd ... --:--:-- --:--:-- --:', '--:--     0']

continuing in command line

calling <lambda>33(15, ['100 '], 'stderr')

<lambda>33 returning ['  % Total ', '   % Received % Xferd ...--:--:-- --:', '--:--     0', '^M100 ']

continuing in command line

calling <lambda>33(15, ['  224  100    56  100   168   107k  '], 'stderr')

<lambda>33 returning ['  % Total ', '   % Received % Xferd ...'  224  100    56  100   168   107k  ']

continuing in command line

calling <lambda>33(15, [' 323k --:--:-- --:--:-- --:--:--  2'], 'stderr')

<lambda>33 returning ['  % Total ', '   % Received % Xferd ... ' 323k --:--:-- --:--:-- --:--:--  2']

continuing in command line

calling <lambda>32(15, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:41.106542Z"}'], 'stdout')

<lambda>32 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:41.106542Z"}']

continuing in command line

calling <lambda>33(15, ['18k', ''], 'stderr')

<lambda>33 returning ['  % Total ', '   % Received % Xferd ...-:--:-- --:--:-- --:--:--  2', '18k^@']

continuing in command line

calling <lambda>33(15, [''], 'stderr')

<lambda>33 returning ['  % Total ', '   % Received % Xferd ...:-- --:--:-- --:--:--  2', '18k^@', '']

continuing in command line

calling <lambda>32(15, [''], 'stdout')

<lambda>32 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:41.106542Z"}', '']

continuing in command line

calling <lambda>34(15, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:41.106542Z"}', ''], ['  % Total ', '   % Received % Xferd ...:-- --:--:-- --:--:--  2', '18k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>34

<lambda>34 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #16

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>36(16, ['  % Total    % Rece'], 'stderr')

<lambda>36 returning ['  % Total    % Rece']

continuing in command line

calling <lambda>36(16, ['ived % Xferd  Average Speed   Time  ... '                                 Dl'], 'stderr')

<lambda>36 returning ['  % Total    % Rece', 'ived % Xferd ...^@                                 Dl']

continuing in command line

calling <lambda>36(16, ['oad  Upload   Total   Spent    Left  Speed', '  0     0    0   '], 'stderr')

<lambda>36 returning ['  % Total    % Rece', 'ived % Xferd ...t    Left  Speed^@^M  0     0    0   ']

continuing in command line

calling <lambda>36(16, ['  0    0     0      0      0 --:--:-- '], 'stderr')

<lambda>36 returning ['  % Total    % Rece', 'ived % Xferd ... 0    0     0      0      0 --:--:-- ']

continuing in command line

calling <lambda>36(16, ['--:--:-- --:--:--     0'], 'stderr')

<lambda>36 returning ['  % Total    % Rece', 'ived % Xferd ... --:--:-- ', '--:--:-- --:--:--     0']

continuing in command line

calling <lambda>36(16, ['100   2'], 'stderr')

<lambda>36 returning ['  % Total    % Rece', 'ived % Xferd ...'--:--:-- --:--:--     0', '^M100   2']

continuing in command line

calling <lambda>35(16, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:46.105665Z"}'], 'stdout')

<lambda>35 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:46.105665Z"}']

continuing in command line

calling <lambda>36(16, ['24  100    56  100   168   104k   314k --:--:-- --:--:-- --:--:--  218k', ''], 'stderr')

<lambda>36 returning ['  % Total    % Rece', 'ived % Xferd ...4k --:--:-- --:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>36(16, [''], 'stderr')

<lambda>36 returning ['  % Total    % Rece', 'ived % Xferd ...-:--:-- --:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>35(16, [''], 'stdout')

<lambda>35 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:46.105665Z"}', '']

continuing in command line

calling <lambda>37(16, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:46.105665Z"}', ''], ['  % Total    % Rece', 'ived % Xferd ...-:--:-- --:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>37

<lambda>37 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #17

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>39(17, ['  % Tot'], 'stderr')

<lambda>39 returning ['  % Tot']

continuing in command line

calling <lambda>39(17, ['al    % Received % Xferd  Average Speed   Time    Time    '], 'stderr')

<lambda>39 returning ['  % Tot', 'al    % Received % Xferd  Average Speed   Time    Time    ']

continuing in command line

calling <lambda>39(17, [' Time  Current', '                  '], 'stderr')

<lambda>39 returning ['  % Tot', 'al    % Received % Xferd ..., ' Time  Current^@                  ']

continuing in command line

calling <lambda>39(17, ['               Dload  Upload   T'], 'stderr')

<lambda>39 returning ['  % Tot', 'al    % Received % Xferd ... ', '               Dload  Upload   T']

continuing in command line

calling <lambda>39(17, ['otal   Spent    Left  Speed', ''], 'stderr')

<lambda>39 returning ['  % Tot', 'al    % Received % Xferd ...   T', 'otal   Spent    Left  Speed^@']

continuing in command line

calling <lambda>39(17, ['  0     0    0     0    0     0   ...   0 --:--:-- --:--:-- --:--:--     0'], 'stderr')

<lambda>39 returning ['  % Tot', 'al    % Received % Xferd ...   0 --:--:-- --:--:-- --:--:--     0']

continuing in command line

calling <lambda>39(17, ['100   22'], 'stderr')

<lambda>39 returning ['  % Tot', 'al    % Received % Xferd ...--:--:-- --:--:--     0', '^M100   22']

continuing in command line

calling <lambda>39(17, ['4  100    56  100   168  66746   195k -'], 'stderr')

<lambda>39 returning ['  % Tot', 'al    % Received % Xferd ... 100    56  100   168  66746   195k -']

continuing in command line

calling <lambda>39(17, ['-:--:-- --:--:-- --:--:--  218k', ''], 'stderr')

<lambda>39 returning ['  % Tot', 'al    % Received % Xferd ...', '-:--:-- --:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>38(17, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:51.113789Z"}'], 'stdout')

<lambda>38 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:51.113789Z"}']

continuing in command line

calling <lambda>39(17, [''], 'stderr')

<lambda>39 returning ['  % Tot', 'al    % Received % Xferd ...-:--:-- --:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>38(17, [''], 'stdout')

<lambda>38 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:51.113789Z"}', '']

continuing in command line

calling <lambda>40(17, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:51.113789Z"}', ''], ['  % Tot', 'al    % Received % Xferd ...-:--:-- --:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>40

<lambda>40 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #18

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>42(18, ['  % Total    % Receiv'], 'stderr')

<lambda>42 returning ['  % Total    % Receiv']

continuing in command line

calling <lambda>42(18, ['ed % Xferd  Average Speed   Time    ...       Dload  Upload   Total   Spent '], 'stderr')

<lambda>42 returning ['  % Total    % Receiv', 'ed % Xferd ...       Dload  Upload   Total   Spent ']

continuing in command line

calling <lambda>42(18, ['   Left  Speed', '  0     0    0  ...   0 --:--:-- --:--:-- --:--:--     0'], 'stderr')

<lambda>42 returning ['  % Total    % Receiv', 'ed % Xferd ...   0 --:--:-- --:--:-- --:--:--     0']

continuing in command line

calling <lambda>42(18, ['100   224  100   '], 'stderr')

<lambda>42 returning ['  % Total    % Receiv', 'ed % Xferd ...--:--:--     0', '^M100   224  100   ']

continuing in command line

calling <lambda>42(18, [' 56  100   168   103k   309k --:--:-- -'], 'stderr')

<lambda>42 returning ['  % Total    % Receiv', 'ed % Xferd ...6  100   168   103k   309k --:--:-- -']

continuing in command line

calling <lambda>42(18, ['-:--:-- --:--:--  218k', ''], 'stderr')

<lambda>42 returning ['  % Total    % Receiv', 'ed % Xferd ...-:--:-- -', '-:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>41(18, ['{"lastExtensionHeartbeat":"2025-08-06T17:00:56.107835Z"}'], 'stdout')

<lambda>41 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:56.107835Z"}']

continuing in command line

calling <lambda>41(18, [''], 'stdout')

<lambda>41 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:00:56.107835Z"}', '']

continuing in command line

calling <lambda>42(18, [''], 'stderr')

<lambda>42 returning ['  % Total    % Receiv', 'ed % Xferd ...:-- -', '-:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>43(18, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:00:56.107835Z"}', ''], ['  % Total    % Receiv', 'ed % Xferd ...:-- -', '-:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>43

<lambda>43 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #19

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>45(19, ['  % Total   '], 'stderr')

<lambda>45 returning ['  % Total   ']

continuing in command line

calling <lambda>45(19, [' % Received % Xferd  Average Speed   Time    Time     Time  Current', '   '], 'stderr')

<lambda>45 returning ['  % Total   ', ' % Received % Xferd ...  Time    Time     Time  Current^@   ']

continuing in command line

calling <lambda>45(19, ['                              Dload ...eft  Speed', '  0     0    0     0 '], 'stderr')

<lambda>45 returning ['  % Total   ', ' % Received % Xferd ... Left  Speed^@^M  0     0    0     0 ']

continuing in command line

calling <lambda>45(19, ['   0     0      0      0 --:--:-- --:-'], 'stderr')

<lambda>45 returning ['  % Total   ', ' % Received % Xferd ...  0     0      0      0 --:--:-- --:-']

continuing in command line

calling <lambda>45(19, ['-:-- --:--:--     0'], 'stderr')

<lambda>45 returning ['  % Total   ', ' % Received % Xferd ... --:--:-- --:-', '-:-- --:--:--     0']

continuing in command line

calling <lambda>45(19, ['100   224 '], 'stderr')

<lambda>45 returning ['  % Total   ', ' % Received % Xferd ... '-:-- --:--:--     0', '^M100   224 ']

continuing in command line

calling <lambda>45(19, [' 100    56  100   168  77134   225k --:--:-- --:--:-- '], 'stderr')

<lambda>45 returning ['  % Total   ', ' % Received % Xferd ... 168  77134   225k --:--:-- --:--:-- ']

continuing in command line

calling <lambda>44(19, ['{"lastExtensionHeartbeat":"2025-08-06T17:01:01.132246Z"}'], 'stdout')

<lambda>44 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:01.132246Z"}']

continuing in command line

calling <lambda>45(19, ['--:--:--  218k', ''], 'stderr')

<lambda>45 returning ['  % Total   ', ' % Received % Xferd ...-:--:-- --:--:-- ', '--:--:--  218k^@']

continuing in command line

calling <lambda>45(19, [''], 'stderr')

<lambda>45 returning ['  % Total   ', ' % Received % Xferd ...:-- --:--:-- ', '--:--:--  218k^@', '']

continuing in command line

calling <lambda>44(19, [''], 'stdout')

<lambda>44 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:01.132246Z"}', '']

continuing in command line

calling <lambda>46(19, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:01:01.132246Z"}', ''], ['  % Total   ', ' % Received % Xferd ...:-- --:--:-- ', '--:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>46

<lambda>46 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #20

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>48(20, ['  % Total    % '], 'stderr')

<lambda>48 returning ['  % Total    % ']

continuing in command line

calling <lambda>48(20, ['Received % Xferd  Average Speed   Ti...Time     Time  Current', '           '], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ...  Time     Time  Current^@           ']

continuing in command line

calling <lambda>48(20, ['                      Dload  Upload   Total   Spent '], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ...       Dload  Upload   Total   Spent ']

continuing in command line

calling <lambda>48(20, ['   Left  Speed', '  0     0    '], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ...t ', '   Left  Speed^@^M  0     0    ']

continuing in command line

calling <lambda>48(20, ['0     0    0     0      0      0 --:--:-- --:'], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ...   0     0      0      0 --:--:-- --:']

continuing in command line

calling <lambda>48(20, ['--:-- --:--:--     0'], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ... --:--:-- --:', '--:-- --:--:--     0']

continuing in command line

calling <lambda>48(20, ['100'], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ... --:', '--:-- --:--:--     0', '^M100']

continuing in command line

calling <lambda>48(20, ['   224  100    56  100   168    '], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ...0', '   224  100    56  100   168    ']

continuing in command line

calling <lambda>48(20, ['99k   297k --:--:-- --:--:-- -'], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ...   ', '99k   297k --:--:-- --:--:-- -']

continuing in command line

calling <lambda>47(20, ['{"lastExtensionHeartbeat":"2025-08-06T17:01:06.105561Z"}'], 'stdout')

<lambda>47 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:06.105561Z"}']

continuing in command line

calling <lambda>48(20, ['-:--:--  218k', ''], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ...-:--:-- --:--:-- -', '-:--:--  218k^@']

continuing in command line

calling <lambda>48(20, [''], 'stderr')

<lambda>48 returning ['  % Total    % ', 'Received % Xferd ...:-- --:--:-- -', '-:--:--  218k^@', '']

continuing in command line

calling <lambda>47(20, [''], 'stdout')

<lambda>47 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:06.105561Z"}', '']

continuing in command line

calling <lambda>49(20, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:01:06.105561Z"}', ''], ['  % Total    % ', 'Received % Xferd ...:-- --:--:-- -', '-:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>49

<lambda>49 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #21

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>51(21, ['  % Total    % Re'], 'stderr')

<lambda>51 returning ['  % Total    % Re']

continuing in command line

calling <lambda>51(21, ['ceived % Xferd  Average Speed   Time...e     Time  Current', '              '], 'stderr')

<lambda>51 returning ['  % Total    % Re', 'ceived % Xferd ...ime     Time  Current^@              ']

continuing in command line

calling <lambda>51(21, ['                   Dload  Upload   Total  '], 'stderr')

<lambda>51 returning ['  % Total    % Re', 'ceived % Xferd ...              Dload  Upload   Total  ']

continuing in command line

calling <lambda>51(21, [' Spent    Left  Speed', '  0 '], 'stderr')

<lambda>51 returning ['  % Total    % Re', 'ceived % Xferd ...al  ', ' Spent    Left  Speed^@^M  0 ']

continuing in command line

calling <lambda>51(21, ['    0    0     0    0     0 '], 'stderr')

<lambda>51 returning ['  % Total    % Re', 'ceived % Xferd ...  0 ', '    0    0     0    0     0 ']

continuing in command line

calling <lambda>51(21, ['     0      0 --:--:-- --:--:'], 'stderr')

<lambda>51 returning ['  % Total    % Re', 'ceived % Xferd ...  0 ', '     0      0 --:--:-- --:--:']

continuing in command line

calling <lambda>51(21, ['-- --:--:--     0'], 'stderr')

<lambda>51 returning ['  % Total    % Re', 'ceived % Xferd ... --:--:-- --:--:', '-- --:--:--     0']

continuing in command line

calling <lambda>51(21, ['100  '], 'stderr')

<lambda>51 returning ['  % Total    % Re', 'ceived % Xferd ...-:--:', '-- --:--:--     0', '^M100  ']

continuing in command line

calling <lambda>50(21, ['{"lastExtensionHeartbeat":"2025-08-06T17:01:11.108051Z"}'], 'stdout')

<lambda>50 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:11.108051Z"}']

continuing in command line

calling <lambda>51(21, [' 224  100    56  100   168   102k   ... --:--:-- --:--:-- --:--:--  218k', ''], 'stderr')

<lambda>51 returning ['  % Total    % Re', 'ceived % Xferd ...8k --:--:-- --:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>50(21, [''], 'stdout')

<lambda>50 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:11.108051Z"}', '']

continuing in command line

calling <lambda>51(21, [''], 'stderr')

<lambda>51 returning ['  % Total    % Re', 'ceived % Xferd ...-:--:-- --:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>52(21, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:01:11.108051Z"}', ''], ['  % Total    % Re', 'ceived % Xferd ...-:--:-- --:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>52

<lambda>52 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #22

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>54(22, ['  % Total    % Rece'], 'stderr')

<lambda>54 returning ['  % Total    % Rece']

continuing in command line

calling <lambda>54(22, ['ived % Xferd  Average Speed   Time  ...rent', '                             '], 'stderr')

<lambda>54 returning ['  % Total    % Rece', 'ived % Xferd ...urrent^@                             ']

continuing in command line

calling <lambda>54(22, ['    Dload  Upload   Total   Spent    Left  Speed'], 'stderr')

<lambda>54 returning ['  % Total    % Rece', 'ived % Xferd ...Upload   Total   Spent    Left  Speed']

continuing in command line

calling <lambda>54(22, ['', '  0     0    0     0    0 '], 'stderr')

<lambda>54 returning ['  % Total    % Rece', 'ived % Xferd ...eed', '^@^M  0     0    0     0    0 ']

continuing in command line

calling <lambda>54(22, ['    0      0      0 --:--:-- '], 'stderr')

<lambda>54 returning ['  % Total    % Rece', 'ived % Xferd ...  0 ', '    0      0      0 --:--:-- ']

continuing in command line

calling <lambda>54(22, ['--:--:-- --:--:--     0'], 'stderr')

<lambda>54 returning ['  % Total    % Rece', 'ived % Xferd ... --:--:-- ', '--:--:-- --:--:--     0']

continuing in command line

calling <lambda>54(22, ['100   224  100   '], 'stderr')

<lambda>54 returning ['  % Total    % Rece', 'ived % Xferd ...--:--:--     0', '^M100   224  100   ']

continuing in command line

calling <lambda>54(22, [' 56  100   168   102k   307k --:--:-- '], 'stderr')

<lambda>54 returning ['  % Total    % Rece', 'ived % Xferd ...56  100   168   102k   307k --:--:-- ']

continuing in command line

calling <lambda>54(22, ['--:--:-- --:--:--  218k', ''], 'stderr')

<lambda>54 returning ['  % Total    % Rece', 'ived % Xferd ...-:--:-- ', '--:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>53(22, ['{"lastExtensionHeartbeat":"2025-08-06T17:01:16.105245Z"}'], 'stdout')

<lambda>53 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:16.105245Z"}']

continuing in command line

calling <lambda>54(22, [''], 'stderr')

<lambda>54 returning ['  % Total    % Rece', 'ived % Xferd ...:-- ', '--:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>53(22, [''], 'stdout')

<lambda>53 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:16.105245Z"}', '']

continuing in command line

calling <lambda>55(22, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:01:16.105245Z"}', ''], ['  % Total    % Rece', 'ived % Xferd ...:-- ', '--:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>55

<lambda>55 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #23

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>57(23, ['  % Total'], 'stderr')

<lambda>57 returning ['  % Total']

continuing in command line

calling <lambda>57(23, ['    % Received % Xferd  Average Speed   Time    Time     '], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd  Average Speed   Time    Time     ']

continuing in command line

calling <lambda>57(23, ['Time  Current', '                     '], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ...'Time  Current^@                     ']

continuing in command line

calling <lambda>57(23, ['            Dload  Upload   Total '], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ..., '            Dload  Upload   Total ']

continuing in command line

calling <lambda>57(23, ['  Spent    Left  Spee'], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ...oad   Total ', '  Spent    Left  Spee']

continuing in command line

calling <lambda>57(23, ['d', '  0     0    0     0    '], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ...Spee', 'd^@^M  0     0    0     0    ']

continuing in command line

calling <lambda>57(23, ['0     0      0      0 -'], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ...     0    ', '0     0      0      0 -']

continuing in command line

calling <lambda>57(23, ['-:--:-- --:--:-- --:--:--     '], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ...0 -', '-:--:-- --:--:-- --:--:--     ']

continuing in command line

calling <lambda>57(23, ['0'], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ... '-:--:-- --:--:-- --:--:--     ', '0']

continuing in command line

calling <lambda>57(23, ['100   '], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ...:--:-- --:--:--     ', '0', '^M100   ']

continuing in command line

calling <lambda>56(23, ['{"lastExtensionHeartbeat":"2025-08-06T17:01:21.133331Z"}'], 'stdout')

<lambda>56 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:21.133331Z"}']

continuing in command line

calling <lambda>57(23, ['224  100    56  100   168  83832   245k --:--:-- --:--:-- --:--:--  218k', ''], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ...5k --:--:-- --:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>57(23, [''], 'stderr')

<lambda>57 returning ['  % Total', '    % Received % Xferd ...-:--:-- --:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>56(23, [''], 'stdout')

<lambda>56 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:21.133331Z"}', '']

continuing in command line

calling <lambda>58(23, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:01:21.133331Z"}', ''], ['  % Total', '    % Received % Xferd ...-:--:-- --:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>58

<lambda>58 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #24

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>60(24, ['  % To'], 'stderr')

<lambda>60 returning ['  % To']

continuing in command line

calling <lambda>60(24, ['tal    % Received % Xferd  Average Speed   Time    Time     Time  '], 'stderr')

<lambda>60 returning ['  % To', 'tal    % Received % Xferd  Average Speed   Time    Time     Time  ']

continuing in command line

calling <lambda>60(24, ['Current', '                             '], 'stderr')

<lambda>60 returning ['  % To', 'tal    % Received % Xferd ...urrent^@                             ']

continuing in command line

calling <lambda>60(24, ['    Dload  Upload   Total   Spen'], 'stderr')

<lambda>60 returning ['  % To', 'tal    % Received % Xferd ... ', '    Dload  Upload   Total   Spen']

continuing in command line

calling <lambda>60(24, ['t    Left  Speed', '  0     0    0...   0 --:--:-- --:--:-- --:--:--     0'], 'stderr')

<lambda>60 returning ['  % To', 'tal    % Received % Xferd ...   0 --:--:-- --:--:-- --:--:--     0']

continuing in command line

calling <lambda>60(24, ['100 '], 'stderr')

<lambda>60 returning ['  % To', 'tal    % Received % Xferd ...:-- --:--:-- --:--:--     0', '^M100 ']

continuing in command line

calling <lambda>60(24, ['  224  100    56  100   168  95726   28'], 'stderr')

<lambda>60 returning ['  % To', 'tal    % Received % Xferd ...224  100    56  100   168  95726   28']

continuing in command line

calling <lambda>60(24, ['0k --:--:-- --:--:-- --:--:--  2'], 'stderr')

<lambda>60 returning ['  % To', 'tal    % Received % Xferd ...8', '0k --:--:-- --:--:-- --:--:--  2']

continuing in command line

calling <lambda>60(24, ['18k', ''], 'stderr')

<lambda>60 returning ['  % To', 'tal    % Received % Xferd ...-:--:-- --:--:-- --:--:--  2', '18k^@']

continuing in command line

calling <lambda>59(24, ['{"lastExtensionHeartbeat":"2025-08-06T17:01:26.104709Z"}'], 'stdout')

<lambda>59 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:26.104709Z"}']

continuing in command line

calling <lambda>60(24, [''], 'stderr')

<lambda>60 returning ['  % To', 'tal    % Received % Xferd ...:-- --:--:-- --:--:--  2', '18k^@', '']

continuing in command line

calling <lambda>59(24, [''], 'stdout')

<lambda>59 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:26.104709Z"}', '']

continuing in command line

calling <lambda>61(24, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:01:26.104709Z"}', ''], ['  % To', 'tal    % Received % Xferd ...:-- --:--:-- --:--:--  2', '18k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>61

<lambda>61 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #25

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>63(25, ['  % Total    % R'], 'stderr')

<lambda>63 returning ['  % Total    % R']

continuing in command line

calling <lambda>63(25, ['eceived % Xferd  Average Speed   Time    Time     Ti'], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd  Average Speed   Time    Time     Ti']

continuing in command line

calling <lambda>63(25, ['me  Current', '                   '], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ...i', 'me  Current^@                   ']

continuing in command line

calling <lambda>63(25, ['              Dload  Upload   '], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ...   ', '              Dload  Upload   ']

continuing in command line

calling <lambda>63(25, ['Total   Spent    Left  Speed', ''], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ...   ', 'Total   Spent    Left  Speed^@']

continuing in command line

calling <lambda>63(25, ['  0     0    0     0    0  '], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ...ed^@', '^M  0     0    0     0    0  ']

continuing in command line

calling <lambda>63(25, ['   0      0      0 --:--:-- -'], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ... 0  ', '   0      0      0 --:--:-- -']

continuing in command line

calling <lambda>63(25, ['-:--:-- --:--:--     0'], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ... --:--:-- -', '-:--:-- --:--:--     0']

continuing in command line

calling <lambda>63(25, ['100   '], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ..., '-:--:-- --:--:--     0', '^M100   ']

continuing in command line

calling <lambda>63(25, ['224  100    56  100   168  98591   288'], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ...24  100    56  100   168  98591   288']

continuing in command line

calling <lambda>63(25, ['k --:--:-- --:--:-- --:--:--  21'], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ...8', 'k --:--:-- --:--:-- --:--:--  21']

continuing in command line

calling <lambda>62(25, ['{"lastExtensionHeartbeat":"2025-08-06T17:01:31.105261Z"}'], 'stdout')

<lambda>62 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:31.105261Z"}']

continuing in command line

calling <lambda>63(25, ['8k', ''], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ...-:--:-- --:--:-- --:--:--  21', '8k^@']

continuing in command line

calling <lambda>62(25, [''], 'stdout')

<lambda>62 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:31.105261Z"}', '']

continuing in command line

calling <lambda>63(25, [''], 'stderr')

<lambda>63 returning ['  % Total    % R', 'eceived % Xferd ...:-- --:--:-- --:--:--  21', '8k^@', '']

continuing in command line

calling <lambda>64(25, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:01:31.105261Z"}', ''], ['  % Total    % R', 'eceived % Xferd ...:-- --:--:-- --:--:--  21', '8k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>64

<lambda>64 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #26

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>66(26, ['  % Total    %'], 'stderr')

<lambda>66 returning ['  % Total    %']

continuing in command line

calling <lambda>66(26, [' Received % Xferd  Average Speed   T...         Dload  Upload   Total   Spen'], 'stderr')

<lambda>66 returning ['  % Total    %', ' Received % Xferd ...         Dload  Upload   Total   Spen']

continuing in command line

calling <lambda>66(26, ['t    Left  Speed', '  0     0    0     0    0     0      '], 'stderr')

<lambda>66 returning ['  % Total    %', ' Received % Xferd ...  0     0    0     0    0     0      ']

continuing in command line

calling <lambda>66(26, ['0      0 --:--:-- --:--:-- --:--:--     '], 'stderr')

<lambda>66 returning ['  % Total    %', ' Received % Xferd ...    0 --:--:-- --:--:-- --:--:--     ']

continuing in command line

calling <lambda>66(26, ['0'], 'stderr')

<lambda>66 returning ['  % Total    %', ' Received % Xferd ... --:--:-- --:--:-- --:--:--     ', '0']

continuing in command line

calling <lambda>66(26, ['100   224  1'], 'stderr')

<lambda>66 returning ['  % Total    %', ' Received % Xferd ... --:--:--     ', '0', '^M100   224  1']

continuing in command line

calling <lambda>66(26, ['00    56  100   168  44979   131k --:--:-- --:--:-- --:--:--  218k'], 'stderr')

<lambda>66 returning ['  % Total    %', ' Received % Xferd ...131k --:--:-- --:--:-- --:--:--  218k']

continuing in command line

calling <lambda>65(26, ['{"lastExtensionHeartbeat":"2025-08-06T17:01:36.116675Z"}'], 'stdout')

<lambda>65 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:36.116675Z"}']

continuing in command line

calling <lambda>66(26, ['', ''], 'stderr')

<lambda>66 returning ['  % Total    %', ' Received % Xferd ...-:--:-- --:--:-- --:--:--  218k', '^@']

continuing in command line

calling <lambda>65(26, [''], 'stdout')

<lambda>65 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:36.116675Z"}', '']

continuing in command line

calling <lambda>66(26, [''], 'stderr')

<lambda>66 returning ['  % Total    %', ' Received % Xferd ...:-- --:--:-- --:--:--  218k', '^@', '']

continuing in command line

calling <lambda>67(26, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:01:36.116675Z"}', ''], ['  % Total    %', ' Received % Xferd ...:-- --:--:-- --:--:--  218k', '
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>67

<lambda>67 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69dd7194'

continuing in codeium#server#RequestMetadata

codeium#server#RequestMetadata returning {'extension_name': 'vim', 'ide_name': ...on': '1.20.8', 'ide_version': '0.11.3'}

continuing in <SNR>111_SendHeartbeat

calling codeium#server#Request('Heartbeat', {'metadata': {'extension_name': 'vim',...n': '1.20.8', 'ide_version': '0.11.3'}})

line 1:   if s:server_port is# v:null
line 2:     throw 'Server port has not been properly initialized.'
line 3:   endif
line 4:   let uri = 'http://127.0.0.1:' . s:server_port . '/exa.language_server_pb.LanguageServerService/' . a:type
line 6:   let data = json_encode(a:data)
line 7:   let args = [ 'curl', '-L', uri, '--header', 'Content-Type: application/json', '-d@-' ]
line 12:   let result = {'out': [], 'err': []}
line 13:   let ExitCallback = a:0 && !empty(a:1) ? a:1 : function('s:NoopCallback')
line 14:   if has('nvim')
line 15:     let jobid = jobstart(args, { 'on_stdout': { channel, data, t -> add(result.out, join(data, "\n")) }, 'on_stderr': { channel, data, t -> add(result.err, join(data, "\n")) }, 'on_exit': { job, status, t -> ExitCallback(result.out, result.err, status) }, })
line 20:     call chansend(jobid, data)
line 21:     call chanclose(jobid, 'stdin')
line 22:     return jobid
codeium#server#Request returning #27

continuing in <SNR>111_SendHeartbeat

line 3:   catch
line 4:     call codeium#log#Exception()
line 5:   endtry
<SNR>111_SendHeartbeat returning #0

continuing in command line

calling <lambda>69(27, ['  % Total    % Received % Xferd  Ave...rrent', '                            '], 'stderr')

<lambda>69 returning ['  % Total    % Received % Xferd  Ave...Current^@                            ']

continuing in command line

calling <lambda>69(27, ['     Dload  Upload   Total   Spent  ...   0 --:--:-- --:--:-- --:--:--     0'], 'stderr')

<lambda>69 returning ['  % Total    % Received % Xferd  Ave...   0 --:--:-- --:--:-- --:--:--     0']

continuing in command line

calling <lambda>69(27, ['100   22'], 'stderr')

<lambda>69 returning ['  % Total    % Received % Xferd  Ave...--:--:-- --:--:--     0', '^M100   22']

continuing in command line

calling <lambda>69(27, ['4  100    56  100   168  36769   107k --:--:-- --:--:-- --:--:--  218k', ''], 'stderr')

<lambda>69 returning ['  % Total    % Received % Xferd  Ave...7k --:--:-- --:--:-- --:--:--  218k^@']

continuing in command line

calling <lambda>68(27, ['{"lastExtensionHeartbeat":"2025-08-06T17:01:41.139729Z"}'], 'stdout')

<lambda>68 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:41.139729Z"}']

continuing in command line

calling <lambda>69(27, [''], 'stderr')

<lambda>69 returning ['  % Total    % Received % Xferd  Ave...-:--:-- --:--:-- --:--:--  218k^@', '']

continuing in command line

calling <lambda>68(27, [''], 'stdout')

<lambda>68 returning ['{"lastExtensionHeartbeat":"2025-08-06T17:01:41.139729Z"}', '']

continuing in command line

calling <lambda>70(27, 0, 'exit')

calling <SNR>111_NoopCallback(['{"lastExtensionHeartbeat":"2025-08-06T17:01:41.139729Z"}', ''], ['  % Total    % Received % Xferd  Ave...-:--:-- --:--:-- --:--:--  218k
', ''], 0)

<SNR>111_NoopCallback returning #0

continuing in <lambda>70

<lambda>70 returning #0

continuing in command line

calling <SNR>111_SendHeartbeat(3)

line 1:   try
line 2:     call codeium#server#Request('Heartbeat', {'metadata': codeium#server#RequestMetadata()})
calling codeium#server#RequestMetadata()

line 1:   return { 'api_key': codeium#command#ApiKey(), 'ide_name':  s:ide, 'ide_version':  s:ide_version, 'extension_name': 'vim', 'extension_version':  s:language_server_version, }
calling codeium#command#ApiKey()

line 1:   if s:api_key == ''
line 2:     echom 'Codeium: No API key found; maybe you need to run `:Codeium Auth`?'
line 3:   endif
line 4:   return s:api_key
codeium#command#ApiKey returning 'b0f29336-2c2c-418a-b0c3-1a6f69
sourcing "nvim_exec2()"
finished sourcing nvim_exec2()
sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim
sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim
could not source "/opt/homebrew/etc/xdg/nvim/sysinit.vim"
could not source "/etc/xdg/nvim/sysinit.vim"
could not source "$VIM/sysinit.vim"
sourcing "/Users/josh/.config/nvim/init.vim"
line 3: sourcing "/Users/josh/.vimrc"
Executing command: "'/bin/zsh' '-c' 'uname -s'"


line 34: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugof.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugof.vim
continuing in /Users/josh/.vimrc
line 34: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indoff.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indoff.vim
continuing in /Users/josh/.vimrc
line 39: sourcing "/Users/josh/.local/share/nvim/site/autoload/plug.vim"
finished sourcing /Users/josh/.local/share/nvim/site/autoload/plug.vim
continuing in /Users/josh/.vimrc
line 86: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua"
line 0: sourcing "nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua:0"
line 2: sourcing "/Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/ftdetect/ghostty.vim"
finished sourcing /Applications/Ghostty.app/Contents/Resources/ghostty/../nvim/site/ftdetect/ghostty.vim
continuing in nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua:0
finished sourcing nvim_exec2() called at /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua:0
continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua
continuing in plug#end
line 86: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin.vim
continuing in plug#end
line 86: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/indent.vim
continuing in plug#end
line 89: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/syntax.vim"
line 20: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/synload.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/synload.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/syntax.vim
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/syntax/syntax.vim
continuing in plug#end
finished sourcing /Users/josh/.vimrc
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/snacks.nvim/plugin/snacks.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-startify/plugin/startify.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/vim-startify/plugin/startify.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
--- Autocommands ---
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/startuptime.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/vim-startuptime/plugin/startuptime.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-highlightedyank/plugin/highlightedyank.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/vim-highlightedyank/plugin/highlightedyank.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua"
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua:0"
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/codeium.vim"
line 8: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/util.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/util.vim
continuing in /Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/codeium.vim
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/plugin/codeium.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-jdtls/plugin/nvim_jdtls.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-jdtls/plugin/nvim_jdtls.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/plugin/gitlab.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/fugitive-gitlab.vim/plugin/gitlab.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-fugitive/plugin/fugitive.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/vim-fugitive/plugin/fugitive.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/vim-fugitive/ftdetect/fugitive.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/vim-fugitive/ftdetect/fugitive.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim"
line 46: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips/map_keys.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips/map_keys.vim
continuing in /Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim
finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/ftdetect/snippets.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/ftdetect/snippets.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-bqf/plugin/bqf.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-bqf/plugin/bqf.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/playground/plugin/nvim-treesitter-playground.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/plugin/colorizer.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/nvim-colorizer.lua/plugin/colorizer.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
Executing ColorSchemePre Autocommands for "*"
autocommand <Lua 103: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/loader.lua:31>

line 1: sourcing "/Users/josh/.local/share/nvim/lazy/gruvbox.nvim/colors/gruvbox.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/gruvbox.nvim/colors/gruvbox.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
Executing ColorScheme Autocommands for "*"
autocommand lua require'lualine'.setup()

line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
--- Autocommands ---
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
Executing ColorScheme Autocommands for "*"
autocommand call s:default_highlight()

Executing ColorScheme Autocommands for "*"
autocommand <Lua 193: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:13>

Executing ColorScheme Autocommands for "*"
autocommand call s:SetStyle()

Executing ColorScheme Autocommands for "*"
autocommand lua require('dapui.config.highlights').setup()

line 0: sourcing "nvim_exec2() called at ColorScheme Autocommands for "*":0"
finished sourcing nvim_exec2() called at ColorScheme Autocommands for "*":0
continuing in ColorScheme Autocommands for "*"
Executing ColorScheme Autocommands for "*"
autocommand <Lua 290: ~/.config/nvim/lua/plugins/treesitter.lua:18>

Executing ColorScheme Autocommands for "*"
autocommand <Lua 182: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:949>

finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/gitsigns.nvim/plugin/gitsigns.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/gitsigns.nvim/plugin/gitsigns.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/editorconfig.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/editorconfig.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/gzip.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/gzip.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/man.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/man.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchit.vim"
not found in 'packpath': "pack/*/start/matchit"
line 3: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchit.vim
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchit.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchparen.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/matchparen.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/netrwPlugin.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/netrwPlugin.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/osc52.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/osc52.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/rplugin.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/rplugin.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/shada.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/shada.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/spellfile.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/spellfile.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tarPlugin.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tarPlugin.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tohtml.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tohtml.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tutor.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/tutor.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/zipPlugin.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/plugin/zipPlugin.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua"
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/plugin/UltiSnips.vim
continuing in nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0"
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider/python3.vim"
line 15: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/remote/host.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/remote/host.vim
continuing in /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider/python3.vim
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider/python3.vim
continuing in nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
line 1: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/autoload/provider.vim
continuing in provider#python3#Require
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
line 0: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/cmp_nvim_ultisnips.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/cmp_nvim_ultisnips.vim
continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
line 0: sourcing "nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0"
finished sourcing nvim_exec2() called at /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua:0
continuing in /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-nvim-ultisnips/after/plugin/cmp_nvim_ultisnips.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/ultisnips/after/plugin/UltiSnips_after.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/ultisnips/after/plugin/UltiSnips_after.vim
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-buffer/after/plugin/cmp_buffer.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-buffer/after/plugin/cmp_buffer.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
line 7: sourcing "nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua
continuing in nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
finished sourcing nvim_exec2() called at /Users/josh/.config/nvim/init.vim:7
continuing in /Users/josh/.config/nvim/init.vim
Executing User Autocommands for "LazyDone"
autocommand <Lua 102: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:183>

finished sourcing /Users/josh/.config/nvim/init.vim
Reading ShaDa file "/Users/josh/.local/state/nvim/shada/main.shada" info marks oldfiles
Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufWinEnter Autocommands for "*"
autocommand <Lua 211: ~/.local/share/nvim/lazy/windows.nvim/lua/windows/autowidth.lua:63>

Executing BufWinEnter Autocommands for "*"
autocommand <Lua 248: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing BufWinEnter Autocommands for "*"
autocommand <Lua 241: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1310>

Executing BufWinEnter Autocommands for "*"
autocommand <Lua 330: ~/.local/share/nvim/lazy/claude-code.nvim/lua/claude-code/file_refresh.lua:37>

Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing BufEnter Autocommands for "*"
autocommand <Lua 74: ~/.config/nvim/lua/config/vim.lua:85>

line 0: sourcing "nvim_exec2() called at BufEnter Autocommands for "*":0"
finished sourcing nvim_exec2() called at BufEnter Autocommands for "*":0
continuing in BufEnter Autocommands for "*"
Executing BufEnter Autocommands for "*"
autocommand <Lua 184: ~/.local/share/nvim/lazy/snacks.nvim/lua/snacks/init.lua:187>

Executing BufEnter Autocommands for "*"
autocommand if codeium#Enabled()|call codeium#command#StartLanguageServer()|endif

line 0: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium.vim
continuing in BufEnter Autocommands for "*"
line 0: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/command.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/command.vim
continuing in BufEnter Autocommands for "*"
autocommand if mode() =~# '^[iR]'|call codeium#DebouncedComplete()|endif

Executing BufEnter Autocommands for "*"
autocommand if expand('%') ==# '' && &previewwindow && pumvisible() && getbufvar('#', '&omnifunc') ==# 'gitlab#omnifunc#handler' |    setlocal nolist linebreak filetype=markdown | endif

Executing BufEnter Autocommands for "*"
autocommand <Lua 238: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1280>

Executing BufEnter Autocommands for "*"
autocommand call v:lua.require'lualine'.refresh({'kind': 'tabpage', 'place': ['statusline'], 'trigger': 'autocmd'})

Executing BufEnter Autocommands for "*"
autocommand <Lua 169: ~/.local/share/nvim/lazy/claude-code.nvim/lua/claude-code/file_refresh.lua:37>

test
Executing BufAdd Autocommands for "*"
autocommand <Lua 260: ~/.local/share/nvim/lazy/oil.nvim/lua/oil/init.lua:1375>

Executing BufReadPost Autocommands for "*"
autocommand <Lua 69: /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/filetype.lua:10>

Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

line 20: sourcing "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin/text.vim"
finished sourcing /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/ftplugin/text.vim
continuing in <SNR>2_LoadFTPlugin
Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

not found in runtime path: "indent/text[.]{vim,lua}"
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing FileType Autocommands for "*"
autocommand <Lua 288: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/install.lua:558>

Executing FileType Autocommands for "*"
autocommand <Lua 289: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

not found in runtime path: "parser/text.*"
Executing FileType Autocommands for "*"
autocommand lua COLORIZER_SETUP_HOOK()

Executing FileType Autocommands for "*"
autocommand call v:lua.require'lualine'.refresh({'kind': 'tabpage', 'place': ['statusline'], 'trigger': 'autocmd'})

autocommand if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif

Executing BufWritePre Autocommands for "*"
autocommand <Lua 165: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

line 0: sourcing "nvim_exec2() called at BufWritePre Autocommands for "*":0"
line 1: sourcing "/Users/josh/.local/share/nvim/lazy/conform.nvim/plugin/conform.lua"
finished sourcing /Users/josh/.local/share/nvim/lazy/conform.nvim/plugin/conform.lua
continuing in nvim_exec2() called at BufWritePre Autocommands for "*":0
finished sourcing nvim_exec2() called at BufWritePre Autocommands for "*":0
continuing in BufWritePre Autocommands for "*"
line 0: sourcing "nvim_exec2() called at BufWritePre Autocommands for "*":0"
finished sourcing nvim_exec2() called at BufWritePre Autocommands for "*":0
continuing in BufWritePre Autocommands for "*"
line 0: sourcing "nvim_exec2() called at BufWritePre Autocommands for "*":0"
finished sourcing nvim_exec2() called at BufWritePre Autocommands for "*":0
continuing in BufWritePre Autocommands for "*"
Executing BufWritePre Autocommands for "*"
autocommand <Lua 434: ~/.local/share/nvim/lazy/conform.nvim/lua/conform/init.lua:98>

"test.txt" 
"test.txt" [New] 0L, 0B written
Skipping undo file write, nothing to undo
Executing BufWritePost Autocommands for "*"
autocommand call v:lua.require'lualine'.refresh({'kind': 'tabpage', 'place': ['statusline'], 'trigger': 'autocmd'})

Executing BufWritePost Autocommands for "*"
autocommand <Lua 319: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns.lua:170>

Executing ExitPre Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/nvim-dap/lua/dap.lua:1358>

Executing BufWinLeave Autocommands for "*"
autocommand <Lua 180: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing VimLeavePre Autocommands for "*"
autocommand call s:on_vimleavepre()

Executing VimLeavePre Autocommands for "*"
autocommand <Lua 179: ~/.local/share/nvim/lazy/mason.nvim/lua/mason/init.lua:9>

autocommand <Lua 205: /opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/lua/vim/lsp.lua:1190>

autocommand <Lua 363: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/async.lua:17>

Executing VimLeavePre Autocommands for "*"
autocommand <Lua 435: ~/.local/share/nvim/lazy/conform.nvim/lua/conform/init.lua:127>

line 0: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/server.vim"

NVIM v0.11.3
Build type: Release
LuaJIT 2.1.1753364724

   system vimrc file: "$VIM/sysinit.vim"
  fall-back for $VIM: "/opt/homebrew/Cellar/neovim/0.11.3/share/nvim"

Run :checkhealth for more info
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/server.vim
continuing in VimLeavePre Autocommands for "*"
Executing command: "'/bin/zsh' '-c' 'uname'"


Executing command: "'/bin/zsh' '-c' 'uname -m'"


line 27: sourcing "/Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/log.vim"
finished sourcing /Users/josh/.local/share/nvim/lazy/codeium.vim/autoload/codeium/log.vim
continuing in <SNR>115_ActuallyStart
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 172: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/attach.lua:401>

Writing ShaDa file "/Users/josh/.local/state/nvim/shada/main.shada"
Executing VimLeave Autocommands for "*"
autocommand call codeium#ServerLeave()
